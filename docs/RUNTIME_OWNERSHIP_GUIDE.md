# Runtime ownership for heap-backed types

Цель: зафиксировать, как устроены строки/массивы/карты (heap-backed) и что делать с владением/ссылками, чтобы не было утечек/циклов.

## Базовая семантика
- Примитивы/малые структуры — inline, без heap.
- `String`/`Array`/`Map` — managed контейнеры со внутренним refcount + copy-on-write (RC/COW):
  - Копирование значения дешёвое (делит буфер, счётчик ссылок).
  - Перезапись/модификация делает copy-on-write (разделение разрывается).
  - Ресурс освобождается, когда refcount падает до 0 (внутренний контроль блока).
- Open-record/`Map<string, Variant>` — аналогично: RC/COW буфер для данных.

## Когда нужны `Shared/Weak`
- Если контейнер живёт в одном месте и передаётся по move — достаточно обычного значения (RC/COW внутри).
- Если контейнер должен разделяться между несколькими владельцами/графами — допускается хранить `String/Array/Map` напрямую (они уже refcounted), но:
  - Глубокие циклы с пользовательскими структурами и обратными ссылками должны разрываться `Weak` (на уровне ваших типов).
  - Для пользовательских объектов/графов: используйте `Shared/Weak` в полях, чтобы управлять циклическими зависимостями.
- Если вы хотите uniform-политику (всё по `Shared/Weak`) — можно оборачивать и контейнеры тоже, но базовый `String/Array/Map` уже сами управляют своими буферами.

## Примеры

### 1) Обычная передача по значению
```mlc
let s1 = "hello"           // String с RC внутри
let s2 = s1                // RC++, дешёвое копирование
s2.append("!")             // COW: s2 получает новый буфер, s1 не меняется
```

### 2) Совместное использование массива
```mlc
let arr1 = [1,2,3]
let arr2 = arr1            // RC++, оба делят буфер
arr2.push(4)               // COW, arr2 теперь со своим буфером
```

### 2b) Общее владение, как в JS (одно хранилище)
```mlc
let a = Shared.new([1,2,3])   // Shared<Array>
let b = a                     // копия Shared, всё ещё одно хранилище

// Концептуальный пример: мутировать через метод, который даёт временный доступ
// (конкретный API в std/mem ещё не определён)
// b.mutate(fn (xs) => xs.push(4))

// Сейчас можно считать, что есть метод, позволяющий безопасно мутировать общее хранилище.
```

### 3) Граф/обратные ссылки (нужен Weak)
```mlc
struct Node {
  children: Shared<Node>[]
  parent: Weak<Node>
}

let root = make_shared(Node{ children: [], parent: Weak::null() })
let leaf = make_shared(Node{ children: [], parent: Weak::null() })
leaf.parent = downgrade(root)
root.children.push(leaf)
// строки/массивы внутри Node остаются managed, но обратные ссылки — Weak
```

### 4) Открытая запись с динамическим payload
```mlc
let payload = { kind: "event", data: [1,2,3] }  // open record, RC/COW внутри
payload.extra = "note"                          // модификация через COW
```

## Правила для лямбд/корутин
- Захватывать `String/Array/Map` можно по значению (RC/COW), безопасно.
- Захват обычных ссылок запрещён для сохраняемых/возвращаемых замыканий; используйте move или `Shared`.

## Диагностики/линты
- Циклы между пользовательскими объектами — предупреждение, требовать Weak на обратной стороне.
- Сырые указатели к буферам контейнеров — только в `unsafe`.

## Итог
- Heap-backed контейнеры безопасно копируются за счёт внутреннего refcount/COW.
- Для пользовательских структур/графов владение/цикл-контроль — через `Shared/Weak`.
- Динамика (open-record/Map) не ломает правила: она тоже RC/COW, но ссылки внутри ваших типов должны подчиняться правилам владения.
