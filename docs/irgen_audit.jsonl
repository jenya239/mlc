{"file":"lib/mlc/irgen/services/loop_service.rb","method":"normalize_loop_body","role":"service","responsibility":"Normalize loop body AST into statement list before visiting","dependencies":["ast_type_checker","ast_factory","statement_visitor"],"issues":[],"notes":"Uses ast_type_checker.block?/unit_literal? helpers to avoid direct AST class checks."}
{"file":"lib/mlc/irgen/reducers/type_reducer.rb","method":"reduce","role":"reducer","responsibility":"Lower AST::TypeDecl into SemanticIR type via TypeDeclarationService","dependencies":["scope_context","type_declaration_service"],"issues":[],"notes":"Follows reducer role: delegates work to service, only scopes current node."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"register_signature","role":"reducer","responsibility":"Preregister function signatures based on type params","dependencies":["type_checker","scope_context","function_registration_service"],"issues":[],"notes":"Returns signature so ProgramReducer can reuse it during lowering."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"reduce","role":"reducer","responsibility":"Lower AST::FuncDecl into SemanticIR::Func (body -> visitors, apply rules, update registry)","dependencies":["type_checker","scope_context","var_type_registry","engine","rule_engine","function_registration_service","function_registry"],"issues":[],"notes":"Accepts precomputed signature (when provided) to avoid recomputing type metadata."}
{"file":"lib/mlc/irgen/reducers/program_reducer.rb","method":"pass_preregister_types","role":"pass","responsibility":"Collect type declarations and run TypeReducer","dependencies":["ast_type_checker","type_reducer"],"issues":[],"notes":"Uses ast_type_checker.type_decl? to avoid direct AST class checks."}
{"file":"lib/mlc/irgen/reducers/program_reducer.rb","method":"pass_preregister_functions","role":"pass","responsibility":"Register function signatures prior to lowering","dependencies":["function_reducer"],"issues":[],"notes":"Registers signatures by delegating to FunctionReducer#register_signature."}
{"file":"lib/mlc/irgen/reducers/program_reducer.rb","method":"pass_lower_declarations","role":"pass","responsibility":"Lower each declaration via the appropriate reducer","dependencies":["function_reducer","type_reducer","ast_type_checker"],"issues":[],"notes":"Switches to ast_type_checker helper and reuses preregistered function signatures from context."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"numeric_type?","role":"service","responsibility":"Determine whether a SemanticIR type counts as numeric for inference","dependencies":["type_checker"],"issues":[],"notes":"Uses TypeChecker::NUMERIC_PRIMITIVES constant instead of depending on container pipeline."}
{"file":"lib/mlc/services/record_builder_service.rb","method":"infer_from_registry","role":"service","responsibility":"Find matching record type in registry based on literal fields","dependencies":["type_registry","type_decl_table","type_unification_service"],"issues":[],"notes":"Now takes registries via initializer, removing pipeline introspection."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"with_type_params","role":"reducer","responsibility":"Scope type parameters during lowering","dependencies":["scope_context"],"issues":[],"notes":"Helper delegates to scope_context; acceptable."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"with_function_return","role":"reducer","responsibility":"Scope expected return type while lowering function body","dependencies":["scope_context"],"issues":[],"notes":"Utility wrapper; fine."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"with_current_node","role":"reducer","responsibility":"Set current AST node for diagnostics","dependencies":["scope_context"],"issues":[],"notes":"Minimal wrapper."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"build_type_annotation","role":"reducer","responsibility":"Lower AST type annotation via TypeBuilder with scoped generics","dependencies":["type_builder","scope_context"],"issues":[],"notes":"Uses type_builder correctly; ensures generic scope."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"build_params","role":"reducer","responsibility":"Convert AST params into SemanticIR params with type checks","dependencies":["type_checker"],"issues":[],"notes":"Validations + builder usage; OK."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"build_function_ir","role":"reducer","responsibility":"Instantiate SemanticIR::Func node","dependencies":[],"issues":[],"notes":"Pure construction; fine."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"apply_function_rules","role":"reducer","responsibility":"Run :core_ir_function rules on lowered function","dependencies":["rule_engine","scope_context","type_registry","effect_analyzer"],"issues":[],"notes":"Appropriate use of rule engine; context assembled inline."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"normalize_function_rule_result","role":"reducer","responsibility":"Coerce rule result back to target function","dependencies":[],"issues":[],"notes":"Handles array outputs to find replacement; OK."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"ensure_return_type!","role":"reducer","responsibility":"Validate return value matches signature","dependencies":["type_checker"],"issues":[],"notes":"Uses type_checker for errors; matches responsibility."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"update_function_registry","role":"reducer","responsibility":"Sync effects/export flags back to registry","dependencies":["function_registry"],"issues":[],"notes":"Runs only if already registered; OK."}
{"file":"lib/mlc/irgen/reducers/function_reducer.rb","method":"void_type?","role":"reducer","responsibility":"Check if SemanticIR type is void/unit","dependencies":["type_checker"],"issues":[],"notes":"Helper only; acceptable."}
{"file":"lib/mlc/irgen/reducers/program_reducer.rb","method":"reduce","role":"reducer","responsibility":"Lower AST::Program into SemanticIR::Module via pass manager","dependencies":["module_context_service","module_import_pass","type_reducer","function_reducer","scope_context"],"issues":[],"notes":"Primary orchestration: scopes module + runs pass manager; acceptable."}
{"file":"lib/mlc/irgen/reducers/program_reducer.rb","method":"with_current_node","role":"reducer","responsibility":"Set current node for diagnostics","dependencies":["scope_context"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/reducers/program_reducer.rb","method":"build_program_pass_manager","role":"pass_manager","responsibility":"Assemble passes executed during program lowering","dependencies":["PassManager"],"issues":[],"notes":"Explicit pass registration; OK though long-term could be configurable."}
{"file":"lib/mlc/irgen/reducers/program_reducer.rb","method":"pass_collect_imports","role":"pass","responsibility":"Run ModuleImportPass and record SemanticIR imports","dependencies":["module_import_pass"],"issues":[],"notes":"Uses SemanticIR::Import builder inline; fine."}
{"file":"lib/mlc/irgen/reducers/program_reducer.rb","method":"pass_register_import_aliases","role":"pass","responsibility":"Placeholder pass (alias registration handled eagerly)","dependencies":[],"issues":[],"notes":"No-op; fine."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"with_type_params","role":"service","responsibility":"Temporarily push type params while building types","dependencies":[],"issues":[],"notes":"Pure stack management; OK."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"build","role":"builder","responsibility":"Convert AST type nodes into SemanticIR types","dependencies":["ir_builder","type_checker","type_registry"],"issues":[],"notes":"Uses case dispatch over AST nodesâ€”acceptable for builder layer."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"build_prim","role":"builder","responsibility":"Lower primitive type or type variable","dependencies":["type_checker"],"issues":[],"notes":"Looks up type params; OK."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"find_type_param","role":"builder","responsibility":"Resolve type param by name","dependencies":[],"issues":[],"notes":"Simple search; fine."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"validate_constraints","role":"builder","responsibility":"Ensure generic args satisfy constraints declared on types","dependencies":["type_registry","type_checker"],"issues":[],"notes":"Delegates to type_checker; fits builder role."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"build","role":"service","responsibility":"Lower match expression/statement by delegating to visitors and analyzer","dependencies":["expression_visitor","statement_visitor","match_analyzer"],"issues":[],"notes":"Correctly decides statement vs expression form."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"build_expression_form","role":"service","responsibility":"Produce SemanticIR::MatchExpr via MatchAnalyzer","dependencies":["match_analyzer","expression_visitor","ir_builder"],"issues":[],"notes":"Delegates arm lowering via lambda; fine."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"build_statement_form","role":"service","responsibility":"Build match-as-statement block expression","dependencies":["expression_visitor","statement_visitor","ir_builder"],"issues":[],"notes":"Wraps match stmt in block returning unit; OK."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"build_expression_arm","role":"service","responsibility":"Produce arm hash for expression matches","dependencies":["var_type_registry","expression_visitor"],"issues":[],"notes":"Snapshots var types; good hygiene."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"build_statement_arm","role":"service","responsibility":"Produce arm hash for statement matches","dependencies":["var_type_registry","expression_visitor","statement_visitor"],"issues":[],"notes":"Mirrors expression version."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"build_pattern","role":"service","responsibility":"Convert AST pattern node to internal descriptor","dependencies":[],"issues":[],"notes":"Straight mapping; acceptable."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"bind_pattern_variables","role":"service","responsibility":"Register pattern bindings in var registry","dependencies":["type_unification_service","var_type_registry"],"issues":[],"notes":"Delegates to helper per kind."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"bind_constructor_pattern","role":"service","responsibility":"Bind constructor fields using unification info","dependencies":["type_unification_service","var_type_registry"],"issues":[],"notes":"Uses fallback unknown_type; OK."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"bind_variable","role":"service","responsibility":"Store binding type in registry","dependencies":["var_type_registry","type_checker"],"issues":[],"notes":"Uses ensure_type!; fine."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"statement_match?","role":"service","responsibility":"Detect if match can be treated as statement","dependencies":["ast_type_checker"],"issues":[],"notes":"Uses ast_type_checker helpers; good."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"statement_safe_pattern?","role":"service","responsibility":"Allow only certain pattern kinds for statement lowering","dependencies":[],"issues":[],"notes":"Simple kind check."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"unit_branch?","role":"service","responsibility":"Check block expr ends with unit result","dependencies":["ast_type_checker"],"issues":[],"notes":"Consistent with AST helpers."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"build_statement_body","role":"service","responsibility":"Convert body AST to block expr returning unit","dependencies":["statement_visitor","ir_builder"],"issues":[],"notes":"Uses helper to extract statements; OK."}
{"file":"lib/mlc/irgen/services/match_service.rb","method":"extract_block_statements","role":"service","responsibility":"Normalize body AST into statement array","dependencies":["ast_type_checker","ast_factory"],"issues":[],"notes":"Properly appends expr stmt for non-unit results."}
{"file":"lib/mlc/irgen/services/loop_service.rb","method":"infer_iterable_element","role":"service","responsibility":"Derive element type from iterable IR","dependencies":["type_checker"],"issues":[],"notes":"Uses type metadata; fine."}
{"file":"lib/mlc/irgen/services/loop_service.rb","method":"with_loop_scope","role":"service","responsibility":"Mark entry/exit of loop scope","dependencies":["scope_context"],"issues":[],"notes":"Delegates to context; OK."}
{"file":"lib/mlc/irgen/services/loop_service.rb","method":"inside_loop?","role":"service","responsibility":"Check loop depth","dependencies":["scope_context"],"issues":[],"notes":"Thin proxy."}
{"file":"lib/mlc/irgen/services/loop_service.rb","method":"save_variable","role":"service","responsibility":"Snapshot variable type","dependencies":["var_type_registry"],"issues":[],"notes":"Returns entry from snapshot; OK."}
{"file":"lib/mlc/irgen/services/loop_service.rb","method":"with_loop_variable","role":"service","responsibility":"Temporarily bind loop variable type","dependencies":["var_type_registry"],"issues":[],"notes":"Restores previous value; fine."}
{"file":"lib/mlc/irgen/services/loop_service.rb","method":"ensure_type!","role":"service","responsibility":"Type validation helper","dependencies":["type_checker"],"issues":[],"notes":"Private helper; no concerns."}
{"file":"lib/mlc/services/record_builder_service.rb","method":"build_anonymous","role":"service","responsibility":"Construct anonymous record literal + type","dependencies":["SemanticIR::Builder"],"issues":[],"notes":"Pure builder logic; OK."}
{"file":"lib/mlc/services/record_builder_service.rb","method":"build_named","role":"service","responsibility":"Construct record literal for named type using registry","dependencies":["type_registry","type_decl_table","type_unification_service"],"issues":[],"notes":"Uses injected registries instead of digging through pipeline state."}
{"file":"lib/mlc/services/record_builder_service.rb","method":"construct_from_info","role":"service","responsibility":"Validate fields against type info and build record expr","dependencies":["type_unification_service","SemanticIR::Builder"],"issues":[],"notes":"Handles generics by unifying field types; OK."}
{"file":"lib/mlc/services/record_builder_service.rb","method":"select_best_candidate","role":"service","responsibility":"Choose record candidate with highest concreteness","dependencies":[],"issues":[],"notes":"Simple comparator."}
{"file":"lib/mlc/irgen/pipeline.rb","method":"initialize","role":"pipeline","responsibility":"Wire services, engine, reducers, and passes","dependencies":["Services::Container","Engine","Passes::ModuleImportPass","Reducers"],"issues":[],"notes":"Initializer now delegates to build_* helpers for services/support/engine/reducers, keeping orchestration readable."}
{"file":"lib/mlc/irgen/pipeline.rb","method":"lower","role":"pipeline","responsibility":"Dispatch AST node to appropriate reducer","dependencies":["program_reducer","function_reducer","type_reducer"],"issues":[],"notes":"Clean dispatcher."}
{"file":"lib/mlc/irgen/pipeline.rb","method":"ensure_default_rules","role":"pipeline","responsibility":"Register default IRGen rules into rule engine","dependencies":["rule_engine"],"issues":[],"notes":"Idempotently registers rule classes; fine."}
{"file":"lib/mlc/irgen/pipeline.rb","method":"register_rule","role":"pipeline","responsibility":"Helper to guard duplicate rule registration","dependencies":["rule_engine"],"issues":[],"notes":"Simple guard; OK."}
{"file":"lib/mlc/irgen/rules/function_effect_rule.rb","method":"matches?","role":"rule","responsibility":"Select SemanticIR::Func nodes eligible for effect analysis","dependencies":[],"issues":[],"notes":"Checks SemanticIR class directly; acceptable."}
{"file":"lib/mlc/irgen/rules/function_effect_rule.rb","method":"produce","role":"rule","responsibility":"Rebuild SemanticIR::Func with updated effects if analysis changes","dependencies":["effect_analyzer"],"issues":[],"notes":"Pure logic, no side effects."}
{"file":"lib/mlc/irgen/visitors/expression_visitor.rb","method":"visit","role":"visitor","responsibility":"Traverse AST expressions, compute child IR, call rules","dependencies":["ast_type_checker","rule_engine","services","statement_visitor"],"issues":[],"notes":"Dispatch factored into helper methods (rule_driven_node?, handle_* helpers) so the main method simply routes to the appropriate handler."}
{"file":"lib/mlc/irgen/visitors/expression_visitor.rb","method":"pipe_op?","role":"visitor","responsibility":"Detect pipe operator","dependencies":[],"issues":[],"notes":"Simple helper."}
{"file":"lib/mlc/irgen/visitors/expression_visitor.rb","method":"desugar_pipe","role":"visitor","responsibility":"Rewrite pipe AST into call AST before visiting","dependencies":["ast_factory","ast_type_checker"],"issues":[],"notes":"Creates new AST nodes via factory; OK."}
{"file":"lib/mlc/irgen/visitors/expression_visitor.rb","method":"build_record_fields","role":"visitor","responsibility":"Visit record literal fields","dependencies":["self"],"issues":[],"notes":"Simple helper."}
{"file":"lib/mlc/irgen/visitors/expression_visitor.rb","method":"apply_rules","role":"visitor","responsibility":"Invoke rule engine for expression stage","dependencies":["rule_engine"],"issues":[],"notes":"Throws if no rule handled node; fine."}
{"file":"lib/mlc/irgen/visitors/expression_visitor.rb","method":"visit_block","role":"visitor","responsibility":"Lower block statements/expressions within expression context","dependencies":["var_type_registry","statement_visitor","type_checker","ast_type_checker","ir_builder"],"issues":[],"notes":"Handles block tail forms; aligns with visitor responsibilities."}
{"file":"lib/mlc/irgen/visitors/expression_visitor.rb","method":"base_context","role":"visitor","responsibility":"Provide baseline rule context","dependencies":["services","statement_visitor","engine"],"issues":[],"notes":"Simple hash builder."}
{"file":"lib/mlc/irgen/visitors/statement_visitor.rb","method":"visit","role":"visitor","responsibility":"Dispatch statements, gather child IR, call rules","dependencies":["ast_type_checker","expression_visitor","rule_engine"],"issues":[],"notes":"Uses AST type checker for branching; clean."}
{"file":"lib/mlc/irgen/visitors/statement_visitor.rb","method":"visit_statements","role":"visitor","responsibility":"Visit list of statements and flatten rule outputs","dependencies":["self"],"issues":[],"notes":"Aggregates results; OK."}
{"file":"lib/mlc/irgen/visitors/statement_visitor.rb","method":"apply_rule","role":"visitor","responsibility":"Invoke :statement rules with context","dependencies":["rule_engine"],"issues":[],"notes":"Simple helper."}
{"file":"lib/mlc/irgen/visitors/statement_visitor.rb","method":"base_context","role":"visitor","responsibility":"Assemble default context hash","dependencies":["services","expression_visitor"],"issues":[],"notes":"Plain data."}
{"file":"lib/mlc/irgen/rules/call_rule.rb","method":"matches?","role":"rule","responsibility":"Check whether node is AST call","dependencies":["ast_type_checker"],"issues":[],"notes":"Rule scoped via ast checker."}
{"file":"lib/mlc/irgen/rules/call_rule.rb","method":"produce","role":"rule","responsibility":"Build SemanticIR call expression leveraging visitors/services","dependencies":["expression_visitor","type_inference_service","ir_builder","scope_context"],"issues":[],"notes":"Largely state-free; proper usage of services."}
{"file":"lib/mlc/rules/delegating_rule.rb","method":"handles","role":"rule_helper","responsibility":"Declare node classes handled and delegate method/context key","dependencies":[],"issues":[],"notes":"Default context key now :pipeline; aligns with new architecture."}
{"file":"lib/mlc/rules/delegating_rule.rb","method":"context_key","role":"rule_helper","responsibility":"Expose context key used for delegation","dependencies":[],"issues":[],"notes":"Provides fallback to :pipeline."}
{"file":"lib/mlc/rules/delegating_rule.rb","method":"applies?","role":"rule_helper","responsibility":"Check if node matches handled classes","dependencies":[],"issues":[],"notes":"Uses Ruby is_a? for rule-specific node classes; acceptable."}
{"file":"lib/mlc/rules/delegating_rule.rb","method":"apply","role":"rule_helper","responsibility":"Forward to delegate method with node","dependencies":[],"issues":[],"notes":"Thin delegator."}
{"file":"lib/mlc/irgen/rules/module_member_rule.rb","method":"matches?","role":"rule","responsibility":"Detect module member accesses resolvable via ModuleResolver","dependencies":["ast_type_checker","module_resolver"],"issues":[],"notes":"Uses services, no direct AST class references."}
{"file":"lib/mlc/irgen/rules/module_member_rule.rb","method":"produce","role":"rule","responsibility":"Rewrite module member access to SemanticIR var reference","dependencies":["module_resolver","type_inference_service","ir_builder"],"issues":[],"notes":"Handles naming/alias logic; fits declarative rule role."}
{"file":"lib/mlc/irgen/rules/module_member_rule.rb","method":"resolve_entry","role":"rule_helper","responsibility":"Look up member info via ModuleResolver","dependencies":["module_resolver","function_registry","ast_type_checker"],"issues":[],"notes":"Pure helper."}
{"file":"lib/mlc/irgen/rules/statements/return_rule.rb","method":"matches?","role":"rule","responsibility":"Check AST return statements","dependencies":["ast_type_checker"],"issues":[],"notes":"Uses service helper."}
{"file":"lib/mlc/irgen/rules/statements/return_rule.rb","method":"produce","role":"rule","responsibility":"Emit SemanticIR return with type validation","dependencies":["type_checker","scope_context","ir_builder","expression context"],"issues":[],"notes":"Ensures return vs void context; uses helper for unit types."}
{"file":"lib/mlc/irgen/rules/statements/return_rule.rb","method":"unit_type?","role":"rule_helper","responsibility":"Test if expected type is unit/void","dependencies":["type_checker"],"issues":[],"notes":"Helper only."}
{"file":"lib/mlc/irgen/services/type_declaration_service.rb","method":"build","role":"service","responsibility":"Lower AST type declaration and register it","dependencies":["type_checker","type_builder","type_registration_service","module_context_service"],"issues":[],"notes":"Keeps responsibilities clear."}
{"file":"lib/mlc/irgen/services/type_declaration_service.rb","method":"specialize_named_type","role":"service","responsibility":"Rename record/sum core types to declared name","dependencies":["SemanticIR::Builder"],"issues":[],"notes":"Simple helper."}
{"file":"lib/mlc/irgen/rules/statements/variable_decl_rule.rb","method":"matches?","role":"rule","responsibility":"Identify AST variable declarations","dependencies":["ast_type_checker"],"issues":[],"notes":"Standard rule gate."}
{"file":"lib/mlc/irgen/rules/statements/variable_decl_rule.rb","method":"produce","role":"rule","responsibility":"Emit SemanticIR variable decl stmt and update var type registry","dependencies":["expression_visitor","type_checker","var_type_registry","ir_builder"],"issues":[],"notes":"Falls back to visitor when value_ir absent; correct."}
{"file":"lib/mlc/irgen/rules/statements/assignment_rule.rb","method":"matches?","role":"rule","responsibility":"Identify assignment statements","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/statements/assignment_rule.rb","method":"produce","role":"rule","responsibility":"Validate/emit assignment statement","dependencies":["expression_visitor","type_checker","var_type_registry","ir_builder","ast_type_checker"],"issues":[],"notes":"Performs necessary checks; fits rule role."}
{"file":"lib/mlc/irgen/rules/statements/while_rule.rb","method":"matches?","role":"rule","responsibility":"Identify AST while statements","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/statements/while_rule.rb","method":"produce","role":"rule","responsibility":"Lower while statement using loop service","dependencies":["loop_service","expression_visitor","statement_visitor","type_checker","ir_builder"],"issues":[],"notes":"Ensures condition boolean; uses loop scope; good."}
{"file":"lib/mlc/irgen/rules/statements/while_rule.rb","method":"ensure_block_expr","role":"rule_helper","responsibility":"Wrap loop body IR in block expr","dependencies":["ir_builder"],"issues":[],"notes":"Simple helper."}
{"file":"lib/mlc/services/type_checker.rb","method":"type_error","role":"service","responsibility":"Raise typed compile errors with origin context","dependencies":["event_bus","current_node_proc"],"issues":[],"notes":"Core diagnostic helper."}
{"file":"lib/mlc/services/type_checker.rb","method":"ensure_compatible_type","role":"service","responsibility":"Check actual vs expected types and publish mismatches","dependencies":["event_bus"],"issues":[],"notes":"Handles auto/type variables; correct place."}
{"file":"lib/mlc/services/type_checker.rb","method":"ensure_boolean_type","role":"service","responsibility":"Validate operand is boolean","dependencies":[],"issues":[],"notes":"Strict check; fine."}
{"file":"lib/mlc/services/type_checker.rb","method":"ensure_numeric_type","role":"service","responsibility":"Validate operand is numeric or constrained type","dependencies":[],"issues":[],"notes":"Relies on numeric_type?; fine."}
{"file":"lib/mlc/irgen/passes/module_import_pass.rb","method":"run","role":"pass","responsibility":"Process program import declarations via ImportService","dependencies":["import_service","function_registry","type_registry"],"issues":[],"notes":"Simple pass; OK."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"build","role":"service","responsibility":"Lower AST lambda into SemanticIR lambda with inferred body type","dependencies":["var_type_registry","expression_visitor","type_checker","ir_builder"],"issues":[],"notes":"Restores var registry snapshot; good hygiene."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"build_params","role":"service","responsibility":"Create lambda params leveraging scope-provided expected types","dependencies":["scope_context","var_type_registry","ir_builder"],"issues":[],"notes":"Handles inferred vs explicit types."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"resolve_param_type","role":"service","responsibility":"Choose param type based on annotation/expectation","dependencies":["type_builder","scope_context"],"issues":[],"notes":"Good separation."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"default_param_type","role":"service","responsibility":"Fallback lambda param type","dependencies":["ir_builder"],"issues":[],"notes":"Currently hardcoded i32; might become configurable later."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"build_explicit_type","role":"service","responsibility":"Lower explicit type annotation within current generics","dependencies":["type_builder","scope_context"],"issues":[],"notes":"Handles type params; OK."}
{"file":"lib/mlc/irgen/rules/statements/for_rule.rb","method":"matches?","role":"rule","responsibility":"Identify AST for statements","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/statements/for_rule.rb","method":"produce","role":"rule","responsibility":"Lower for loop using LoopService","dependencies":["loop_service","expression_visitor","statement_visitor","ir_builder"],"issues":[],"notes":"Uses loop variable scope helpers; good."}
{"file":"lib/mlc/irgen/rules/statements/for_rule.rb","method":"ensure_block_expr","role":"rule_helper","responsibility":"Wrap normalized body into block expr","dependencies":["ir_builder"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/rules/statements/if_rule.rb","method":"matches?","role":"rule","responsibility":"Identify AST if statements","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/statements/if_rule.rb","method":"produce","role":"rule","responsibility":"Lower if statement by lowering condition and bodies","dependencies":["expression_visitor","statement_visitor","type_checker","ir_builder","loop_service"],"issues":[],"notes":"Validates condition boolean."}
{"file":"lib/mlc/irgen/rules/statements/if_rule.rb","method":"build_block","role":"rule_helper","responsibility":"Normalize branch body into block","dependencies":["loop_service","ir_builder"],"issues":[],"notes":"Uses loop_service helper for block normalization; acceptable."}
{"file":"lib/mlc/irgen/rules/if_rule.rb","method":"matches?","role":"rule","responsibility":"Detect AST if expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/if_rule.rb","method":"produce","role":"rule","responsibility":"Lower if expression by visiting branches","dependencies":["expression_visitor","type_checker","ir_builder"],"issues":[],"notes":"Uses helper to enforce branch types."}
{"file":"lib/mlc/irgen/rules/if_rule.rb","method":"determine_type","role":"rule_helper","responsibility":"Compute resulting type of if expression","dependencies":["type_checker","ir_builder"],"issues":[],"notes":"Ensures compatibility when else present."}
{"file":"lib/mlc/irgen/rules/literal_rule.rb","method":"matches?","role":"rule","responsibility":"Delegate literal detection to LiteralProcessor","dependencies":["literal_processor","ast_type_checker"],"issues":[],"notes":"Declarative."}
{"file":"lib/mlc/irgen/rules/literal_rule.rb","method":"produce","role":"rule","responsibility":"Build literal IR via LiteralProcessor","dependencies":["literal_processor","ast_type_checker"],"issues":[],"notes":"Direct delegation; OK."}
{"file":"lib/mlc/irgen/rules/var_ref_rule.rb","method":"matches?","role":"rule","responsibility":"Identify var references","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/var_ref_rule.rb","method":"produce","role":"rule","responsibility":"Build SemanticIR var expression","dependencies":["identifier_type_resolver","ir_builder"],"issues":[],"notes":"Simple; fine."}
{"file":"lib/mlc/irgen/rules/member_rule.rb","method":"matches?","role":"rule","responsibility":"Detect member accesses that are not module members","dependencies":["ast_type_checker","module_resolver"],"issues":[],"notes":"Checks module member via resolver."}
{"file":"lib/mlc/irgen/rules/member_rule.rb","method":"produce","role":"rule","responsibility":"Emit SemanticIR member expression","dependencies":["expression_visitor","member_access_service","ir_builder"],"issues":[],"notes":"Uses service for type resolution; good."}
{"file":"lib/mlc/irgen/rules/record_literal_rule.rb","method":"matches?","role":"rule","responsibility":"Identify AST record literals","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/record_literal_rule.rb","method":"produce","role":"rule","responsibility":"Build SemanticIR record literal via RecordLiteralBuilder","dependencies":["record_literal_builder","expression_visitor"],"issues":[],"notes":"Delegates building to service."}
{"file":"lib/mlc/irgen/rules/record_literal_rule.rb","method":"build_fields","role":"rule_helper","responsibility":"Visit record literal fields","dependencies":["expression_visitor"],"issues":[],"notes":"Helper only."}
{"file":"lib/mlc/irgen/rules/array_literal_rule.rb","method":"matches?","role":"rule","responsibility":"Identify AST array literals","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/array_literal_rule.rb","method":"produce","role":"rule","responsibility":"Build SemanticIR array literal via ArrayLiteralBuilder","dependencies":["array_literal_builder","expression_visitor"],"issues":[],"notes":"Delegates to service."}
{"file":"lib/mlc/irgen/rules/array_literal_rule.rb","method":"build_elements","role":"rule_helper","responsibility":"Visit each element","dependencies":["expression_visitor"],"issues":[],"notes":"Simple helper."}
{"file":"lib/mlc/irgen/rules/block_rule.rb","method":"matches?","role":"rule","responsibility":"Identify AST block expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/block_rule.rb","method":"produce","role":"rule","responsibility":"Lower block expr to SemanticIR block","dependencies":["statement_visitor","expression_visitor","var_type_registry","ir_builder"],"issues":[],"notes":"Snapshots var types; good practice."}
{"file":"lib/mlc/irgen/rules/do_rule.rb","method":"matches?","role":"rule","responsibility":"Identify do expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/do_rule.rb","method":"produce","role":"rule","responsibility":"Desugar do expr into block expr and visit","dependencies":["expression_visitor","ast_factory","ir_builder"],"issues":[],"notes":"Creates block AST via factory then reuses visitor; good reuse."}
{"file":"lib/mlc/irgen/rules/unary_rule.rb","method":"matches?","role":"rule","responsibility":"Detect AST unary ops","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/unary_rule.rb","method":"produce","role":"rule","responsibility":"Build SemanticIR unary op","dependencies":["type_inference_service","ir_builder"],"issues":[],"notes":"Uses operand_ir from visitor; fits pattern."}
{"file":"lib/mlc/irgen/rules/binary_rule.rb","method":"matches?","role":"rule","responsibility":"Detect binary expressions (non pipe)","dependencies":["ast_type_checker"],"issues":[],"notes":"Pipe handled in visitor."}
{"file":"lib/mlc/irgen/rules/binary_rule.rb","method":"produce","role":"rule","responsibility":"Build SemanticIR binary op","dependencies":["type_inference_service","ir_builder"],"issues":[],"notes":"Uses left/right IR passed via context."}
{"file":"lib/mlc/irgen/rules/let_rule.rb","method":"matches?","role":"rule","responsibility":"Detect AST let expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/let_rule.rb","method":"produce","role":"rule","responsibility":"Lower let binding into block expression","dependencies":["expression_visitor","var_type_registry","type_checker","ir_builder"],"issues":[],"notes":"Restores var snapshot; correct."}
{"file":"lib/mlc/irgen/rules/let_rule.rb","method":"ensure_type!","role":"rule_helper","responsibility":"Forward to type checker for diagnostics","dependencies":["type_checker"],"issues":[],"notes":"Helper only."}
{"file":"lib/mlc/irgen/rules/lambda_rule.rb","method":"matches?","role":"rule","responsibility":"Detect lambda expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/lambda_rule.rb","method":"produce","role":"rule","responsibility":"Delegate lambda lowering to LambdaService","dependencies":["lambda_service","expression_visitor"],"issues":[],"notes":"Defer logic to service; appropriate."}
{"file":"lib/mlc/irgen/rules/list_comprehension_rule.rb","method":"matches?","role":"rule","responsibility":"Identify list comprehension expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/list_comprehension_rule.rb","method":"produce","role":"rule","responsibility":"Delegate to ListComprehensionService","dependencies":["list_comprehension_service","expression_visitor"],"issues":[],"notes":"Service handles heavy lifting."}
{"file":"lib/mlc/irgen/rules/match_rule.rb","method":"matches?","role":"rule","responsibility":"Identify match expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/match_rule.rb","method":"produce","role":"rule","responsibility":"Delegate match lowering to MatchService","dependencies":["match_service","expression_visitor","statement_visitor"],"issues":[],"notes":"Service handles logic."}
{"file":"lib/mlc/irgen/rules/index_access_rule.rb","method":"matches?","role":"rule","responsibility":"Detect index access expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/index_access_rule.rb","method":"produce","role":"rule","responsibility":"Delegate to IndexAccessService to build expression","dependencies":["expression_visitor","index_access_service","ir_builder"],"issues":[],"notes":"Service handles validation."}
{"file":"lib/mlc/irgen/rules/while_loop_rule.rb","method":"matches?","role":"rule","responsibility":"Identify while expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/while_loop_rule.rb","method":"produce","role":"rule","responsibility":"Lower while loop expression to block that executes stmt","dependencies":["loop_service","expression_visitor","statement_visitor","type_checker","ir_builder"],"issues":[],"notes":"Wraps statement in block returning unit; aligns with semantics."}
{"file":"lib/mlc/irgen/rules/while_loop_rule.rb","method":"build_block_expr","role":"rule_helper","responsibility":"Create block expr from statements with unit","dependencies":["ir_builder"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/rules/for_loop_rule.rb","method":"matches?","role":"rule","responsibility":"Detect for-loop expressions","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/for_loop_rule.rb","method":"produce","role":"rule","responsibility":"Lower for-loop expression to block","dependencies":["loop_service","expression_visitor","statement_visitor","ir_builder"],"issues":[],"notes":"Uses loop scope + variable helpers; returns block expr."}
{"file":"lib/mlc/irgen/rules/for_loop_rule.rb","method":"build_block_expr","role":"rule_helper","responsibility":"Wrap statements in unit-returning block","dependencies":["ir_builder"],"issues":[],"notes":"Same pattern as while."}
{"file":"lib/mlc/irgen/rules/statements/break_rule.rb","method":"matches?","role":"rule","responsibility":"Detect break statements","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/statements/break_rule.rb","method":"produce","role":"rule","responsibility":"Emit break node ensuring loop context","dependencies":["loop_service","type_checker","ir_builder"],"issues":[],"notes":"Checks loop scope; good."}
{"file":"lib/mlc/irgen/rules/statements/continue_rule.rb","method":"matches?","role":"rule","responsibility":"Detect continue statements","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/statements/continue_rule.rb","method":"produce","role":"rule","responsibility":"Emit continue node with loop check","dependencies":["loop_service","type_checker","ir_builder"],"issues":[],"notes":"Same pattern as break."}
{"file":"lib/mlc/irgen/rules/statements/expr_stmt_rule.rb","method":"matches?","role":"rule","responsibility":"Identify expression statements","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/statements/expr_stmt_rule.rb","method":"produce","role":"rule","responsibility":"Lower expression statement","dependencies":["expression_visitor","ir_builder"],"issues":[],"notes":"Simple builder call."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"infer_variable_type","role":"service","responsibility":"Resolve type of variable or function identifier","dependencies":["var_type_registry","function_registry","type_checker"],"issues":[],"notes":"Handles builtins and booleans; errors via type_error."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"infer_call_type","role":"service","responsibility":"Infer result type of call expressions","dependencies":["type_checker","function_registry","generic_call_resolver","type_checker"],"issues":[],"notes":"Large method but core inference logic; acceptable."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"infer_binary_type","role":"service","responsibility":"Determine binary operator result type","dependencies":["type_checker"],"issues":[],"notes":"Covers numeric/string cases; fine."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"infer_unary_type","role":"service","responsibility":"Determine unary operator type","dependencies":["type_checker"],"issues":[],"notes":"Validations handled appropriately."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"expected_lambda_param_types","role":"service","responsibility":"Infer expected lambda params for higher-order calls","dependencies":[],"issues":[],"notes":"Currently limited to array helpers; documented behavior."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"infer_iterable_type","role":"service","responsibility":"Get element type from iterable IR","dependencies":[],"issues":[],"notes":"Simple case for arrays; errors otherwise."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"infer_member_type","role":"service","responsibility":"Resolve type of member access based on object","dependencies":["type_registry","type_checker"],"issues":[],"notes":"Handles generic types, arrays, strings; may be further extended later."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"unify_types","role":"service","responsibility":"Bind type variables during generic inference","dependencies":["type_checker","type_unification_service"],"issues":[],"notes":"Core unification logic; acceptable."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"substitute_type","role":"service","responsibility":"Replace type vars with inferred concrete types","dependencies":[],"issues":[],"notes":"Recursive transformation; fine."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"infer_type_arguments","role":"service","responsibility":"Infer generic args based on parameter/argument types","dependencies":[],"issues":[],"notes":"Uses unify_types; OK."}
{"file":"lib/mlc/irgen/services/index_access_service.rb","method":"build","role":"service","responsibility":"Validate and build index access expression","dependencies":["type_checker","ir_builder"],"issues":[],"notes":"Ensures array + numeric index; good."}
{"file":"lib/mlc/irgen/services/index_access_service.rb","method":"ensure_array!","role":"service","responsibility":"Raise error if object not array","dependencies":["type_checker"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve","role":"service","responsibility":"Determine member access type (generic or concrete)","dependencies":["type_checker","type_registry"],"issues":[],"notes":"Delegates to helper methods; appropriate."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_generic_member","role":"service","responsibility":"Resolve member on generic type using registry info","dependencies":["type_checker","type_registry","type_decl_table"],"issues":[],"notes":"Handles fallback to concrete core type."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"substitute_generic_member","role":"service","responsibility":"Substitute generic parameters when resolving member type","dependencies":["type_decl_table"],"issues":[],"notes":"Uses type_map; OK."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_concrete_member","role":"service","responsibility":"Resolve member types for concrete record/array/string/numeric","dependencies":["type_registry","type_checker"],"issues":[],"notes":"Covers multiple cases; manageable."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_array_member","role":"service","responsibility":"Handle array-specific members","dependencies":[],"issues":[],"notes":"Uses constants to bound known members."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_string_member","role":"service","responsibility":"Handle string member methods","dependencies":[],"issues":[],"notes":"Returns primitives or array(\"string\")."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_numeric_member","role":"service","responsibility":"Handle numeric-specific members","dependencies":[],"issues":[],"notes":"Currently only sqrt; errors otherwise."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"substitute_type","role":"service","responsibility":"Replace type vars in member types","dependencies":["SemanticIR::Builder"],"issues":[],"notes":"Recursive substitution; fine."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"primitive_type","role":"service","responsibility":"Helper returning primitive type via IRBuilder","dependencies":["ir_builder"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"function_placeholder","role":"service","responsibility":"Build placeholder function type","dependencies":["SemanticIR::Builder"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"raise_unknown_member","role":"service","responsibility":"Emit error for missing member","dependencies":["type_checker"],"issues":[],"notes":"Provides known members list; good."}
{"file":"lib/mlc/irgen/rules/index_access_rule.rb","method":"matches?","role":"rule","responsibility":"Detect AST index accesses","dependencies":["ast_type_checker"],"issues":[],"notes":"OK."}
{"file":"lib/mlc/irgen/rules/index_access_rule.rb","method":"produce","role":"rule","responsibility":"Lower index access via IndexAccessService","dependencies":["expression_visitor","index_access_service","ir_builder"],"issues":[],"notes":"Delegates to service; no state."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"types_compatible?","role":"service","responsibility":"Check compatibility of two SemanticIR types","dependencies":[],"issues":[],"notes":"Allows numeric flexibility; fine."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"string_type?","role":"service","responsibility":"Predicate for string types","dependencies":[],"issues":[],"notes":"Simple helper."}
{"file":"lib/mlc/services/type_inference_service.rb","method":"void_type?","role":"service","responsibility":"Predicate for void/unit types","dependencies":[],"issues":[],"notes":"Helper used in various contexts."}
{"file":"lib/mlc/irgen/services/list_comprehension_service.rb","method":"build","role":"service","responsibility":"Lower list comprehension by visiting generators/filters/output","dependencies":["var_type_registry","loop_service","expression_visitor","ir_builder"],"issues":[],"notes":"Restores snapshot; clean."}
{"file":"lib/mlc/irgen/services/list_comprehension_service.rb","method":"build_generators","role":"service","responsibility":"Lower generator clauses and register loop vars","dependencies":["expression_visitor","loop_service","var_type_registry"],"issues":[],"notes":"Uses loop_service to infer element types."}
{"file":"lib/mlc/irgen/services/list_comprehension_service.rb","method":"default_element_type","role":"service","responsibility":"Fallback type when output lacks type","dependencies":["ir_builder"],"issues":[],"notes":"Currently defaults to i32; might be configurable later."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"predicate_suite","role":"service","responsibility":"Expose AST predicate helpers (var_ref?, call?, list_comprehension?, etc.)","dependencies":[],"issues":[],"notes":"Centralizes node class checks; patterns encourage using this service instead of direct is_a? in other code."}
{"file":"lib/mlc/irgen/services/literal_processor.rb","method":"supported?","role":"service","responsibility":"Check if AST node is supported literal","dependencies":["ast_type_checker"],"issues":[],"notes":"Uses literal_kind helper; fine."}
{"file":"lib/mlc/irgen/services/literal_processor.rb","method":"build","role":"service","responsibility":"Build SemanticIR literal based on kind","dependencies":["ast_type_checker","ir_builder"],"issues":[],"notes":"Delegates to helpers per kind."}
{"file":"lib/mlc/irgen/services/literal_processor.rb","method":"build_numeric_literal","role":"service","responsibility":"Construct numeric literal IR","dependencies":["ir_builder"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/literal_processor.rb","method":"build_string_literal","role":"service","responsibility":"Construct string literal","dependencies":["ir_builder"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/literal_processor.rb","method":"build_regex_literal","role":"service","responsibility":"Construct regex literal","dependencies":["ir_builder"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/literal_processor.rb","method":"build_unit_literal","role":"service","responsibility":"Construct unit literal","dependencies":["ir_builder"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/expression_type_resolver.rb","method":"unary_type","role":"service","responsibility":"Infer unary operator result type","dependencies":["type_checker","ir_builder"],"issues":[],"notes":"Validates operands appropriately."}
{"file":"lib/mlc/irgen/services/expression_type_resolver.rb","method":"binary_type","role":"service","responsibility":"Infer binary operator result type","dependencies":["type_checker","ir_builder"],"issues":[],"notes":"Covers numeric/string/logical cases."}
{"file":"lib/mlc/irgen/services/expression_type_resolver.rb","method":"ensure_numeric_pair","role":"service","responsibility":"Helper to enforce numeric operands","dependencies":["type_checker"],"issues":[],"notes":"Private helper."}
{"file":"lib/mlc/irgen/services/expression_type_resolver.rb","method":"combine_numeric","role":"service","responsibility":"Choose resulting numeric type based on precedence","dependencies":[],"issues":[],"notes":"Uses precedence map; fine."}
{"file":"lib/mlc/irgen/services/expression_type_resolver.rb","method":"float_type","role":"service","responsibility":"Build float SemanticIR type","dependencies":["ir_builder"],"issues":[],"notes":"Helper used by combine_numeric."}
{"file":"lib/mlc/irgen/services/identifier_type_resolver.rb","method":"type_for","role":"service","responsibility":"Resolve identifier type using var registry, function entries, IO fallbacks","dependencies":["var_type_registry","function_registry","ir_builder"],"issues":[],"notes":"Raises errors with scope info when missing."}
{"file":"lib/mlc/irgen/services/identifier_type_resolver.rb","method":"function_type_from_info","role":"service","responsibility":"Build function type from registry info","dependencies":["ir_builder"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/identifier_type_resolver.rb","method":"io_return_kind","role":"service","responsibility":"Lookup IO builtin return type","dependencies":["TypeChecker::IO_RETURN_TYPES"],"issues":[],"notes":"Uses TypeChecker constant; acceptable."}
{"file":"lib/mlc/irgen/services/identifier_type_resolver.rb","method":"io_type","role":"service","responsibility":"Build IO builtin return type","dependencies":["ir_builder"],"issues":[],"notes":"Covers string/array/bool cases."}
{"file":"lib/mlc/irgen/services/ir_builder.rb","method":"builder_suite","role":"builder","responsibility":"Provide constructors for all SemanticIR nodes (var, call, block, stmt, types, literals)","dependencies":[],"issues":[],"notes":"File is a collection of thin wrappers over SemanticIR classes; no logic beyond construction."}
{"file":"lib/mlc/services/module_context_service.rb","method":"with_current_module","role":"service","responsibility":"Scope current module name/namespace when lowering","dependencies":[],"issues":[],"notes":"Restores previous context; clean."}
{"file":"lib/mlc/services/module_context_service.rb","method":"with_import_aliases","role":"service","responsibility":"Scope import alias map","dependencies":[],"issues":[],"notes":"Simple context helper."}
{"file":"lib/mlc/services/module_context_service.rb","method":"derive_module_namespace","role":"service","responsibility":"Compute namespace string from module path","dependencies":[],"issues":[],"notes":"Handles main/nil case; OK."}
{"file":"lib/mlc/services/module_context_service.rb","method":"build_module_alias_keys","role":"service","responsibility":"Build possible alias names for function","dependencies":[],"issues":[],"notes":"Uses module_alias_prefixes; fine."}
{"file":"lib/mlc/services/module_context_service.rb","method":"module_alias_prefixes","role":"service","responsibility":"Collect unique module/alias prefixes","dependencies":[],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/services/module_context_service.rb","method":"register_module_import","role":"service","responsibility":"Register aliases for imported module functions","dependencies":["function_registry"],"issues":[],"notes":"Iterates over registry entries; handles argument errors gracefully."}
{"file":"lib/mlc/irgen/engine.rb","method":"initialize","role":"engine","responsibility":"Wire services and visitors into rule engine","dependencies":["services","rule_engine"],"issues":[],"notes":"Constructs visitors, links them; no business logic."}
{"file":"lib/mlc/irgen/engine.rb","method":"run","role":"engine","responsibility":"Apply rule engine for arbitrary stage","dependencies":["rule_engine","services"],"issues":[],"notes":"Thin wrapper."}
{"file":"lib/mlc/irgen/engine.rb","method":"run_expression","role":"engine","responsibility":"Visit expression node via ExpressionVisitor","dependencies":["expression_visitor"],"issues":[],"notes":"Direct delegation."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"int_literal","role":"builder","responsibility":"Construct IntLit AST node for visitors/tests","dependencies":["MLC::AST::IntLit"],"issues":[],"notes":"Pure value object creation; no logic."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"float_literal","role":"builder","responsibility":"Construct FloatLit AST node","dependencies":["MLC::AST::FloatLit"],"issues":[],"notes":"Wrapper for constructor."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"string_literal","role":"builder","responsibility":"Construct StringLit AST node","dependencies":["MLC::AST::StringLit"],"issues":[],"notes":"Thin wrapper."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"regex_literal","role":"builder","responsibility":"Construct RegexLit AST node with pattern+flags","dependencies":["MLC::AST::RegexLit"],"issues":[],"notes":"Validates nothing; caller responsible."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"unit_literal","role":"builder","responsibility":"Construct UnitLit AST node","dependencies":["MLC::AST::UnitLit"],"issues":[],"notes":"Used to avoid manual constant references."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"var_ref","role":"builder","responsibility":"Construct VarRef AST node","dependencies":["MLC::AST::VarRef"],"issues":[],"notes":"Keeps node creation centralized."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"member_access","role":"builder","responsibility":"Construct MemberAccess AST node","dependencies":["MLC::AST::MemberAccess"],"issues":[],"notes":"No embedded logic."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"index_access","role":"builder","responsibility":"Construct IndexAccess AST node","dependencies":["MLC::AST::IndexAccess"],"issues":[],"notes":"Straight instantiation."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"call","role":"builder","responsibility":"Construct Call AST node","dependencies":["MLC::AST::Call"],"issues":[],"notes":"Avoids direct constructor usage downstream."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"unary","role":"builder","responsibility":"Construct UnaryOp AST node","dependencies":["MLC::AST::UnaryOp"],"issues":[],"notes":"Pure wrapper."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"binary","role":"builder","responsibility":"Construct BinaryOp AST node","dependencies":["MLC::AST::BinaryOp"],"issues":[],"notes":"Pure wrapper."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"lambda","role":"builder","responsibility":"Construct Lambda AST node","dependencies":["MLC::AST::Lambda"],"issues":[],"notes":"Only packages params/body."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"lambda_param","role":"builder","responsibility":"Construct LambdaParam AST node","dependencies":["MLC::AST::LambdaParam"],"issues":[],"notes":"Delegates to AST struct."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"let","role":"builder","responsibility":"Construct Let AST node","dependencies":["MLC::AST::Let"],"issues":[],"notes":"Keeps mutable/type flags centralized."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"record_literal","role":"builder","responsibility":"Construct RecordLit AST node","dependencies":["MLC::AST::RecordLit"],"issues":[],"notes":"No additional logic."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"array_literal","role":"builder","responsibility":"Construct ArrayLiteral AST node","dependencies":["MLC::AST::ArrayLiteral"],"issues":[],"notes":"Simple instantiation."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"generator","role":"builder","responsibility":"Construct Generator AST node for comprehensions","dependencies":["MLC::AST::Generator"],"issues":[],"notes":"Pure builder."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"list_comprehension","role":"builder","responsibility":"Construct ListComprehension AST node","dependencies":["MLC::AST::ListComprehension"],"issues":[],"notes":"Normalizes filters to array; acceptable."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"block_expr","role":"builder","responsibility":"Construct BlockExpr AST node","dependencies":["MLC::AST::BlockExpr"],"issues":[],"notes":"Simple wrapper."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"expr_stmt","role":"builder","responsibility":"Construct ExprStmt AST node","dependencies":["MLC::AST::ExprStmt"],"issues":[],"notes":"Thin wrapper."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"variable_decl","role":"builder","responsibility":"Construct VariableDecl AST node","dependencies":["MLC::AST::VariableDecl"],"issues":[],"notes":"Keeps argument order consistent."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"return_stmt","role":"builder","responsibility":"Construct Return AST node","dependencies":["MLC::AST::Return"],"issues":[],"notes":"Handles optional expr; no logic."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"do_expr","role":"builder","responsibility":"Construct DoExpr AST node","dependencies":["MLC::AST::DoExpr"],"issues":[],"notes":"Used by DoRule; fine."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"assignment","role":"builder","responsibility":"Construct Assignment AST node","dependencies":["MLC::AST::Assignment"],"issues":[],"notes":"Straight instantiation."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"break_stmt","role":"builder","responsibility":"Construct Break AST node","dependencies":["MLC::AST::Break"],"issues":[],"notes":"Pure wrapper."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"continue_stmt","role":"builder","responsibility":"Construct Continue AST node","dependencies":["MLC::AST::Continue"],"issues":[],"notes":"Pure wrapper."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"for_loop","role":"builder","responsibility":"Construct ForLoop AST node","dependencies":["MLC::AST::ForLoop"],"issues":[],"notes":"No internal validation."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"while_loop","role":"builder","responsibility":"Construct WhileLoop AST node","dependencies":["MLC::AST::WhileLoop"],"issues":[],"notes":"Simple constructor call."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"block","role":"builder","responsibility":"Construct Block statement AST node","dependencies":["MLC::AST::Block"],"issues":[],"notes":"Wraps stmt array; OK."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"if_stmt","role":"builder","responsibility":"Construct IfStmt AST node","dependencies":["MLC::AST::IfStmt"],"issues":[],"notes":"No branching logic."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"match_expr","role":"builder","responsibility":"Construct MatchExpr AST node","dependencies":["MLC::AST::MatchExpr"],"issues":[],"notes":"Delegates to struct."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"match_arm","role":"builder","responsibility":"Build hash representing match arm payload","dependencies":[],"issues":[],"notes":"Keeps arm schema consistent; not an AST object."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"pattern_wildcard","role":"builder","responsibility":"Construct wildcard Pattern node","dependencies":["MLC::AST::Pattern"],"issues":[],"notes":"Simple wrapper."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"pattern_literal","role":"builder","responsibility":"Construct literal Pattern node","dependencies":["MLC::AST::Pattern"],"issues":[],"notes":"Encapsulates data hash shape."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"pattern_var","role":"builder","responsibility":"Construct variable Pattern node","dependencies":["MLC::AST::Pattern"],"issues":[],"notes":"Thin builder."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"pattern_constructor","role":"builder","responsibility":"Construct constructor Pattern node","dependencies":["MLC::AST::Pattern"],"issues":[],"notes":"Array(fields) ensures array semantics; good normalization."}
{"file":"lib/mlc/irgen/services/ast_factory.rb","method":"pattern_regex","role":"builder","responsibility":"Construct regex Pattern node","dependencies":["MLC::AST::Pattern"],"issues":[],"notes":"Normalizes bindings array; OK."}
{"file":"lib/mlc/irgen/services/module_resolver.rb","method":"initialize","role":"service","responsibility":"Provide alias map backing store","dependencies":[],"issues":[],"notes":"Stores alias hash; no side effects."}
{"file":"lib/mlc/irgen/services/module_resolver.rb","method":"resolve_alias","role":"service","responsibility":"Map alias to canonical module name","dependencies":[],"issues":[],"notes":"Falls back to original string; minimal logic."}
{"file":"lib/mlc/irgen/services/module_resolver.rb","method":"add_alias","role":"service","responsibility":"Register alias mapping","dependencies":[],"issues":[],"notes":"Direct hash mutation; acceptable."}
{"file":"lib/mlc/irgen/services/module_resolver.rb","method":"register_module_import","role":"service","responsibility":"Expand import decl into function registry alias registrations","dependencies":["function_registry"],"issues":[],"notes":"Handles import_all vs items, builds prefixes; no stray AST coupling."}
{"file":"lib/mlc/irgen/services/module_resolver.rb","method":"register_alias_for","role":"service","responsibility":"Safely register single alias in registry","dependencies":["function_registry"],"issues":[],"notes":"Ignores duplicate/invalid combos via silent rescue; acceptable for idempotency."}
{"file":"lib/mlc/irgen/services/module_resolver.rb","method":"resolve_member_function","role":"service","responsibility":"Lookup module member entry via function registry","dependencies":["function_registry","ast_type_checker"],"issues":[],"notes":"Only examines AST via checker; respects layering."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"initialize","role":"service","responsibility":"Inject builder/type services for record literals","dependencies":["ir_builder","type_registry","type_checker","record_builder_service"],"issues":[],"notes":"Simple wiring."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"build","role":"service","responsibility":"Produce SemanticIR record expr resolving type names and fields","dependencies":["type_registry","record_builder_service","ir_builder","type_checker"],"issues":[],"notes":"Now enforces per-field types before branching and reuses named/anonymous helpers."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"normalize_fields","role":"service_helper","responsibility":"Convert symbolish field keys to strings preserving IR values","dependencies":[],"issues":[],"notes":"Keeps field map normalized."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"build_named_record","role":"service_helper","responsibility":"Validate fields against declared record type then build via registry service","dependencies":["type_registry","type_checker","record_builder_service"],"issues":[],"notes":"Delegates matching to assert_field_names_match! before building."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"inferred_record_type","role":"service_helper","responsibility":"Fallback builder for inferred/anonymous record types","dependencies":["record_builder_service"],"issues":[],"notes":"Delegates entirely to RecordBuilderService."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"ensure_field_types!","role":"service_helper","responsibility":"Run ensure_expr_type! for every record field before building","dependencies":["type_checker"],"issues":[],"notes":"Prevents unnamed fields with nil type metadata."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"ensure_expr_type!","role":"service_helper","responsibility":"Ensure each field expression has a resolved type","dependencies":["type_checker"],"issues":[],"notes":"Called by ensure_field_types! during build."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"assert_field_names_match!","role":"service_helper","responsibility":"Verify record literal field order matches definition","dependencies":["type_checker"],"issues":[],"notes":"Single source of mismatch error used by build_named_record."}
{"file":"lib/mlc/irgen/services/record_literal_builder.rb","method":"resolve_type_name","role":"service_helper","responsibility":"Derive canonical record type name from type metadata","dependencies":[],"issues":[],"notes":"Walks base_type chain; no side effects."}
{"file":"lib/mlc/irgen/services/type_registration_service.rb","method":"initialize","role":"service","responsibility":"Wire registry + constructor services","dependencies":["type_registry","type_decl_table","sum_type_constructor_service"],"issues":[],"notes":"Dependency injection only."}
{"file":"lib/mlc/irgen/services/type_registration_service.rb","method":"register","role":"service","responsibility":"Register user type metadata and optional constructors","dependencies":["type_registry","type_decl_table","sum_type_constructor_service"],"issues":[],"notes":"Keeps exported/namespace flags consistent."}
{"file":"lib/mlc/irgen/services/type_registration_service.rb","method":"register_constructors_if_needed","role":"service_helper","responsibility":"Register constructors for sum types only","dependencies":["sum_type_constructor_service","MLC::SemanticIR::SumType"],"issues":[],"notes":"Guards via type check; no extra coupling."}
{"file":"lib/mlc/irgen/services/type_declaration_service.rb","method":"initialize","role":"service","responsibility":"Inject type builder/checker deps","dependencies":["type_checker","type_builder","type_registration_service","module_context_service"],"issues":[],"notes":"No logic."}
{"file":"lib/mlc/irgen/services/type_declaration_service.rb","method":"build","role":"service","responsibility":"Lower AST type decl to SemanticIR and register it","dependencies":["type_checker","type_builder","type_registration_service","module_context_service","MLC::SemanticIR::TypeDecl"],"issues":[],"notes":"Wraps builder in with_type_params scope then registers; respects roles."}
{"file":"lib/mlc/irgen/services/type_declaration_service.rb","method":"specialize_named_type","role":"service_helper","responsibility":"Rebuild record/sum types with declared name","dependencies":["MLC::SemanticIR::RecordType","MLC::SemanticIR::SumType","MLC::SemanticIR::Builder"],"issues":[],"notes":"Prevents anonymous type names from leaking."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"initialize","role":"service","responsibility":"Inject builder/checker/registry deps and param stack","dependencies":["ir_builder","type_checker","type_registry"],"issues":[],"notes":"Initializes stack for generics."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"with_type_params","role":"service","responsibility":"Scope active type parameters while building nested types","dependencies":[],"issues":[],"notes":"Ensures stack unwinds via ensure block; safe for recursion."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"build","role":"service","responsibility":"Lower AST type nodes into SemanticIR types","dependencies":["ir_builder","MLC::AST"],"issues":[],"notes":"Case statement handles all supported nodes; raises compile error otherwise."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"build_prim","role":"service_helper","responsibility":"Resolve primitive vs type-parameter references","dependencies":["ir_builder"],"issues":[],"notes":"Prefers type params via stack before prim type."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"find_type_param","role":"service_helper","responsibility":"Search active type param stack for name","dependencies":[],"issues":[],"notes":"Reverse iteration ensures inner scope precedence."}
{"file":"lib/mlc/irgen/services/type_builder.rb","method":"validate_constraints","role":"service_helper","responsibility":"Ensure generic args satisfy declared constraints","dependencies":["type_registry","type_checker"],"issues":[],"notes":"Reads constraint from AST metadata; errors through type_checker."}
{"file":"lib/mlc/irgen/services/array_literal_builder.rb","method":"initialize","role":"service","responsibility":"Inject IR builder and type checker deps","dependencies":["ir_builder","type_checker"],"issues":[],"notes":"Wiring only."}
{"file":"lib/mlc/irgen/services/array_literal_builder.rb","method":"build","role":"service","responsibility":"Assemble SemanticIR array literal with validated element types","dependencies":["ir_builder","type_checker"],"issues":[],"notes":"Delegates inference/validation to helpers."}
{"file":"lib/mlc/irgen/services/array_literal_builder.rb","method":"infer_element_type","role":"service_helper","responsibility":"Choose array element type based on first element or default","dependencies":["ir_builder","type_checker"],"issues":[],"notes":"Ensures first element has a type before using it; defaults to i32 when empty."}
{"file":"lib/mlc/irgen/services/array_literal_builder.rb","method":"validate_elements","role":"service_helper","responsibility":"Ensure each element matches inferred element type","dependencies":["type_checker"],"issues":[],"notes":"Skips redundant comparison for index 0."}
{"file":"lib/mlc/irgen/services/array_literal_builder.rb","method":"ensure_element_type!","role":"service_helper","responsibility":"Raise when literal element lacks inferred type","dependencies":["type_checker"],"issues":[],"notes":"Used by inference + validation helpers."}
{"file":"lib/mlc/irgen/services/list_comprehension_service.rb","method":"initialize","role":"service","responsibility":"Inject builder/loop/type-registry deps","dependencies":["ir_builder","loop_service","var_type_registry"],"issues":[],"notes":"Wiring only."}
{"file":"lib/mlc/irgen/services/list_comprehension_service.rb","method":"build","role":"service","responsibility":"Lower list comprehension AST into SemanticIR expression","dependencies":["expression_visitor","loop_service","var_type_registry","ir_builder"],"issues":[],"notes":"Snapshots var types before visiting; restores after ensure."}
{"file":"lib/mlc/irgen/services/list_comprehension_service.rb","method":"build_generators","role":"service_helper","responsibility":"Visit generator iterables and bind element var types","dependencies":["expression_visitor","loop_service","var_type_registry"],"issues":[],"notes":"Mutates var registry per generator then accumulates metadata."}
{"file":"lib/mlc/irgen/services/list_comprehension_service.rb","method":"default_element_type","role":"service_helper","responsibility":"Fallback element type for missing inference","dependencies":["ir_builder"],"issues":[],"notes":"Defaults to i32 consistent with other literal builders."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"initialize","role":"service","responsibility":"Wire builder/checker/registry/scope deps for lambda lowering","dependencies":["ir_builder","type_checker","var_type_registry","scope_context","type_builder"],"issues":[],"notes":"Stores DEFAULT_PARAM_TYPE constant."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"build","role":"service","responsibility":"Lower lambda AST to SemanticIR lambda expr with scoped params","dependencies":["expression_visitor","ir_builder","type_checker","var_type_registry","scope_context"],"issues":[],"notes":"Snapshots var registry; enforces body type presence."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"build_params","role":"service_helper","responsibility":"Visit lambda params, infer types, register in var registry","dependencies":["scope_context","var_type_registry","ir_builder"],"issues":[],"notes":"Respects scope-provided expected param types."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"resolve_param_type","role":"service_helper","responsibility":"Pick explicit param type, expected override, or default","dependencies":["type_builder","scope_context","ir_builder"],"issues":[],"notes":"Delegates to build_explicit_type for typed params."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"default_param_type","role":"service_helper","responsibility":"Provide fallback param type when unspecified","dependencies":["ir_builder"],"issues":[],"notes":"Uses DEFAULT_PARAM_TYPE constant (i32)."}
{"file":"lib/mlc/irgen/services/lambda_service.rb","method":"build_explicit_type","role":"service_helper","responsibility":"Build explicit param type respecting current type params","dependencies":["type_builder","scope_context"],"issues":[],"notes":"Wraps type_builder.with_type_params only when necessary."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"initialize","role":"service","responsibility":"Wire type checker/registry tables for member resolution","dependencies":["type_checker","type_registry","type_decl_table","ir_builder"],"issues":[],"notes":"Stores static member maps for primitives."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve","role":"service","responsibility":"Determine member type for given object type","dependencies":["type_checker","type_registry"],"issues":[],"notes":"Delegates to generic vs concrete branches after ensuring object type exists."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_generic_member","role":"service_helper","responsibility":"Resolve members defined on generic base types with substitution fallback","dependencies":["type_checker","type_registry","type_decl_table"],"issues":[],"notes":"Tries registry-defined members before falling back to core type."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"substitute_generic_member","role":"service_helper","responsibility":"Substitute type variables inside member type using actual generic args","dependencies":["type_decl_table","type_checker"],"issues":[],"notes":"Builds name -> arg map from decl params."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_concrete_member","role":"service_helper","responsibility":"Handle members for concrete record/array/string/numeric types","dependencies":["type_registry","type_checker","ir_builder"],"issues":[],"notes":"Falls back to raise_unknown_member when no handler applies."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_array_member","role":"service_helper","responsibility":"Map array members to primitive/function placeholder types","dependencies":["ir_builder"],"issues":[],"notes":"Returns function placeholders for map/filter/fold."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_string_member","role":"service_helper","responsibility":"Provide member types for strings or raise type_checker error","dependencies":["ir_builder","type_checker"],"issues":[],"notes":"Uses builder for array return and consistent diagnostics."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"resolve_numeric_member","role":"service_helper","responsibility":"Handle numeric intrinsic members","dependencies":["ir_builder","type_checker"],"issues":[],"notes":"Currently only supports sqrt."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"substitute_type","role":"service_helper","responsibility":"Recursively substitute type variables in member types","dependencies":["MLC::SemanticIR::Builder"],"issues":[],"notes":"Covers TypeVariable/Generic/Array/Function shapes; returns original when unchanged."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"primitive_type","role":"service_helper","responsibility":"Build primitive SemanticIR type via ir_builder","dependencies":["ir_builder"],"issues":[],"notes":"Shared by string/array helpers."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"function_placeholder","role":"service_helper","responsibility":"Provide placeholder function type for higher-order members","dependencies":["ir_builder"],"issues":[],"notes":"Delegates to injected builder for consistency."}
{"file":"lib/mlc/irgen/services/member_access_service.rb","method":"raise_unknown_member","role":"service_helper","responsibility":"Emit consistent type error for unsupported members","dependencies":["type_checker"],"issues":[],"notes":"Includes known member list when provided."}
{"file":"lib/mlc/irgen/services/index_access_service.rb","method":"initialize","role":"service","responsibility":"Inject type checker for index validation","dependencies":["type_checker"],"issues":[],"notes":"Simple wiring."}
{"file":"lib/mlc/irgen/services/index_access_service.rb","method":"build","role":"service","responsibility":"Validate array/index types and build SemanticIR index expression","dependencies":["type_checker","ir_builder"],"issues":[],"notes":"Ensures object is array, index numeric, returns element type."}
{"file":"lib/mlc/irgen/services/index_access_service.rb","method":"ensure_array!","role":"service_helper","responsibility":"Raise type error when index target isn't array","dependencies":["type_checker","MLC::SemanticIR::ArrayType"],"issues":[],"notes":"Uses type_checker.describe_type for message."}
{"file":"lib/mlc/irgen/services/semantic_ir_classifier.rb","method":"var_expr?","role":"service","responsibility":"Predicate for SemanticIR variable expressions","dependencies":["MLC::SemanticIR::VarExpr"],"issues":[],"notes":"Thin helper to avoid is_a? calls elsewhere."}
{"file":"lib/mlc/irgen/services/semantic_ir_classifier.rb","method":"call_expr?","role":"service","responsibility":"Predicate for SemanticIR call expressions","dependencies":["MLC::SemanticIR::CallExpr"],"issues":[],"notes":"Thin helper."}
{"file":"lib/mlc/irgen/services/semantic_ir_classifier.rb","method":"member_expr?","role":"service","responsibility":"Predicate for SemanticIR member expressions","dependencies":["MLC::SemanticIR::MemberExpr"],"issues":[],"notes":"Thin helper."}
{"file":"lib/mlc/irgen/services/container.rb","method":"initialize","role":"service","responsibility":"Compose all IRGen V2 services and shared registries","dependencies":["function_registry","type_registry","event_bus"],"issues":[],"notes":"Initialization broken into build_* helper methods (core/flow/type/import/high-level), keeping wiring readable."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"var_ref?","role":"service","responsibility":"Predicate for AST VarRef nodes","dependencies":["MLC::AST::VarRef"],"issues":[],"notes":"Allows rules to avoid direct is_a? calls."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"member_access?","role":"service","responsibility":"Predicate for AST MemberAccess nodes","dependencies":["MLC::AST::MemberAccess"],"issues":[],"notes":"Thin helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"call?","role":"service","responsibility":"Predicate for AST Call nodes","dependencies":["MLC::AST::Call"],"issues":[],"notes":"Thin helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"literal?","role":"service","responsibility":"Predicate for literal superclass","dependencies":["MLC::AST::Literal"],"issues":[],"notes":"Provides coarse literal flag."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"int_literal?","role":"service","responsibility":"Predicate for IntLit","dependencies":["MLC::AST::IntLit"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"float_literal?","role":"service","responsibility":"Predicate for FloatLit","dependencies":["MLC::AST::FloatLit"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"string_literal?","role":"service","responsibility":"Predicate for StringLit","dependencies":["MLC::AST::StringLit"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"regex_literal?","role":"service","responsibility":"Predicate for RegexLit","dependencies":["MLC::AST::RegexLit"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"unit_literal?","role":"service","responsibility":"Predicate for UnitLit","dependencies":["MLC::AST::UnitLit"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"literal_kind","role":"service","responsibility":"Return symbolic literal kind","dependencies":[],"issues":[],"notes":"Maps to :int/:float/:string/:regex/:unit or nil."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"let?","role":"service","responsibility":"Predicate for Let expressions","dependencies":["MLC::AST::Let"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"if_expr?","role":"service","responsibility":"Predicate for AST IfExpr","dependencies":["MLC::AST::IfExpr"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"match_expr?","role":"service","responsibility":"Predicate for AST MatchExpr","dependencies":["MLC::AST::MatchExpr"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"binary_op?","role":"service","responsibility":"Predicate for BinaryOp","dependencies":["MLC::AST::BinaryOp"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"unary_op?","role":"service","responsibility":"Predicate for UnaryOp","dependencies":["MLC::AST::UnaryOp"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"record_literal?","role":"service","responsibility":"Predicate for RecordLit","dependencies":["MLC::AST::RecordLit"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"array_literal?","role":"service","responsibility":"Predicate for ArrayLiteral","dependencies":["MLC::AST::ArrayLiteral"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"block_expr?","role":"service","responsibility":"Predicate for BlockExpr","dependencies":["MLC::AST::BlockExpr"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"do_expr?","role":"service","responsibility":"Predicate for DoExpr","dependencies":["MLC::AST::DoExpr"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"for_loop?","role":"service","responsibility":"Predicate for ForLoop expr form","dependencies":["MLC::AST::ForLoop"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"while_loop_expr?","role":"service","responsibility":"Predicate for WhileLoop expr form","dependencies":["MLC::AST::WhileLoop"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"index_access?","role":"service","responsibility":"Predicate for IndexAccess","dependencies":["MLC::AST::IndexAccess"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"lambda?","role":"service","responsibility":"Predicate for Lambda expr","dependencies":["MLC::AST::Lambda"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"list_comprehension?","role":"service","responsibility":"Predicate for ListComprehension","dependencies":["MLC::AST::ListComprehension"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"block_statement?","role":"service","responsibility":"Predicate for Block statements","dependencies":["MLC::AST::Block"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"expr_stmt?","role":"service","responsibility":"Predicate for ExprStmt","dependencies":["MLC::AST::ExprStmt"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"variable_decl_statement?","role":"service","responsibility":"Predicate for VariableDecl statements","dependencies":["MLC::AST::VariableDecl"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"return_statement?","role":"service","responsibility":"Predicate for Return statement","dependencies":["MLC::AST::Return"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"assignment_statement?","role":"service","responsibility":"Predicate for Assignment statement","dependencies":["MLC::AST::Assignment"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"break_statement?","role":"service","responsibility":"Predicate for Break","dependencies":["MLC::AST::Break"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"continue_statement?","role":"service","responsibility":"Predicate for Continue","dependencies":["MLC::AST::Continue"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"if_statement?","role":"service","responsibility":"Predicate for IfStmt","dependencies":["MLC::AST::IfStmt"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"while_statement?","role":"service","responsibility":"Predicate for WhileStmt","dependencies":["MLC::AST::WhileStmt"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"for_statement?","role":"service","responsibility":"Predicate for ForLoop statement form","dependencies":["MLC::AST::ForLoop"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"var_decl?","role":"service","responsibility":"Predicate for VarDecl (legacy) nodes","dependencies":["MLC::AST::VarDecl"],"issues":[],"notes":"Helper retained for compatibility; consider removing if type no longer used."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"function_def?","role":"service","responsibility":"Predicate for FunctionDef nodes","dependencies":["MLC::AST::FunctionDef"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/ast_type_checker.rb","method":"class_def?","role":"service","responsibility":"Predicate for ClassDef nodes","dependencies":["MLC::AST::ClassDef"],"issues":[],"notes":"Helper."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"initialize","role":"service","responsibility":"Inject stdlib/module/type services for imports","dependencies":["stdlib_registry","module_resolver","type_builder","type_declaration_service","type_registration_service","type_checker"],"issues":[],"notes":"Wires everything needed for stdlib + user import flows."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"process","role":"service","responsibility":"Dispatch import declarations to stdlib or user handlers","dependencies":["module_resolver","stdlib_registry"],"issues":[],"notes":"Thin branching by module path."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"stdlib_module?","role":"service_helper","responsibility":"Check if module exists in stdlib registry","dependencies":["stdlib_registry"],"issues":[],"notes":"Returns metadata or nil."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"process_stdlib_import","role":"service","responsibility":"Register stdlib functions/types into registries","dependencies":["stdlib_registry","function_registry","type_registration_service","type_checker","type_builder"],"issues":[],"notes":"Handles import_all vs item lists; raises compile error for unknown items."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"register_function","role":"service_helper","responsibility":"Register stdlib function signature + aliases","dependencies":["type_checker","type_builder","function_registry"],"issues":[],"notes":"Uses local FunctionSignature struct so V2 no longer depends on legacy IRGen namespace."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"register_aliases","role":"service_helper","responsibility":"Register module/alias prefixes for function names","dependencies":["function_registry"],"issues":[],"notes":"Skips canonical duplication."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"safe_register_alias","role":"service_helper","responsibility":"Invoke registry alias registration with graceful error handling","dependencies":["function_registry"],"issues":[],"notes":"Silently ignores duplicates via rescue."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"register_type","role":"service_helper","responsibility":"Register stdlib type declarations via builders","dependencies":["type_checker","type_builder","type_registration_service"],"issues":[],"notes":"Mirrors TypeDeclarationService flow for stdlib metadata."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"rename_core_type","role":"service_helper","responsibility":"Ensure record/sum core types carry exported name","dependencies":["MLC::SemanticIR::Builder"],"issues":[],"notes":"Matches logic from TypeDeclarationService."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"build_type","role":"service_helper","responsibility":"Guarded type_builder invocation","dependencies":["type_builder"],"issues":[],"notes":"Returns nil when type AST missing."}
{"file":"lib/mlc/irgen/services/import_service.rb","method":"process_user_import","role":"service","responsibility":"Delegate user imports to ModuleResolver","dependencies":["module_resolver","function_registry"],"issues":[],"notes":"Thin delegation; module_resolver handles aliasing."}
{"file":"lib/mlc/irgen/rules/base_rule.rb","method":"applies?","role":"rule_helper","responsibility":"Invoke subclass matches? with node/context","dependencies":[],"issues":[],"notes":"Thin wrapper for RuleEngine compatibility."}
{"file":"lib/mlc/irgen/rules/base_rule.rb","method":"apply","role":"rule_helper","responsibility":"Delegate to produce","dependencies":[],"issues":[],"notes":"No side effects; ensures consistent API."}
{"file":"lib/mlc/irgen/rules/base_rule.rb","method":"matches?","role":"rule_helper","responsibility":"Abstract matcher hook","dependencies":[],"issues":[],"notes":"Raises NotImplementedError; enforces override."}
{"file":"lib/mlc/irgen/rules/base_rule.rb","method":"produce","role":"rule_helper","responsibility":"Abstract producer hook","dependencies":[],"issues":[],"notes":"Same as above."}
{"file":"lib/mlc/irgen/rules/base_rule.rb","method":"services","role":"rule_helper","responsibility":"Convenience accessor for shared services container in context","dependencies":[],"issues":[],"notes":"Hides context layout from subclasses."}
{"file":"lib/mlc/irgen/passes/module_import_pass_test.rb","method":"setup","role":"test","responsibility":"Wire ModuleImportPass with lightweight fake import service","dependencies":["FakeImportService","FunctionRegistry","TypeRegistry","ModuleImportPass"],"issues":[],"notes":"Drops dependency on Services::Container to keep fixtures fast."}
{"file":"lib/mlc/irgen/passes/module_import_pass_test.rb","method":"test_processes_each_import_with_registries","role":"test","responsibility":"Ensure pass invokes import service for every import node and forwards registries","dependencies":["FakeImportService","AST::ImportDecl"],"issues":[],"notes":"Validates both call count and arguments."}
{"file":"lib/mlc/irgen/passes/module_import_pass_test.rb","method":"test_handles_program_without_imports","role":"test","responsibility":"Verify pass is no-op when program has no imports","dependencies":["FakeImportService","AST::Program"],"issues":[],"notes":"Guards against nil imports regressions."}
{"file":"lib/mlc/irgen/passes/module_import_pass_test.rb","method":"FakeImportService#process","role":"test_helper","responsibility":"Capture calls for verification","dependencies":[],"issues":[],"notes":"Simple struct-like helper; keeps tests declarative."}
{"file":"lib/mlc/function_signature.rb","method":"FunctionSignature#initialize","role":"value_object","responsibility":"Struct encapsulating name/param_types/ret_type/type_params for function metadata","dependencies":[],"issues":[],"notes":"Shared across IRGen V2 services/tests to avoid legacy IRGen::FunctionInfo coupling."}
{"file":"lib/mlc/services/function_registration_service.rb","method":"register_function_signature","role":"service","responsibility":"Persist function signature metadata into registry","dependencies":["function_registry","module_context_service","FunctionSignature"],"issues":[],"notes":"Now builds signatures via shared FunctionSignature struct instead of legacy IRGen constant."}
{"file":"lib/mlc/services/metadata_loader_service.rb","method":"register_function_from_metadata","role":"service","responsibility":"Reconstruct FunctionSignature from .mlcmeta and register it","dependencies":["function_registry","FunctionSignature"],"issues":[],"notes":"Keeps imported functions aligned with new signature struct."}
{"file":"lib/mlc/services/sum_type_constructor_service.rb","method":"register_sum_type_constructors","role":"service","responsibility":"Generate constructor signatures for sum-type variants","dependencies":["function_registry","sum_type_constructors","FunctionSignature"],"issues":[],"notes":"Constructors registered using shared FunctionSignature to avoid legacy structs."}
{"file":"lib/mlc/services/type_unification_service.rb","method":"constructor_info_for","role":"service","responsibility":"Specialize constructor signatures for concrete scrutinee types","dependencies":["sum_type_constructors","FunctionSignature"],"issues":[],"notes":"Returns FunctionSignature instances after substitution, removing IRGen constant dependency."}
