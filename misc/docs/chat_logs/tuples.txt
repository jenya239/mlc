перепроверь что насчёт поддержки в нашем проекте кортежей и символов. это должны быть first class citizens. есть ли с этим какие-то проблемы, скажем концептуальные с трансляцией в c++?


• Explored
  └ Search tuple|кортеж|symbol|символ in mlc
    Read nodes.rb
    Search tuple in semantic

─ Worked for 17s ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

• Текущая поддержка:

  - Кортежи: в AST есть TupleType (через type_parser), в C++ AST DSL есть tuple тип → генерируется как std::tuple<...>. Но в SemanticIR/правилах нет явного упоминания tuple-выражений или операций; по коду не видно полноценной поддержки кортежных литералов/деструктуризации/передачи. Вероятно кортежи лишь тип для многопараметрных ф-ций/вариантов, но не как
    полноценные значения.
  - Символы: “symbol” в коде встречается в контексте names/metadata, но нет first-class Symbol типа/литералов в языке. C++ DSL оперирует символами Ruby (как API), но это про DSL, не про язык MLC.

  Проблемы/риски для first-class поддержки:

  - Нужно определить синтаксис: литералы кортежей (a, b)? деструктуризация? pattern match? Должно пройти через parser → SemanticIR → backend.
  - SemanticIR и type inference сейчас не покрывают tuple-выражения/операции. Надо добавить IR-узлы и правила (type checker, inference).
  - Backend: C++ генерация tuple literal и std::get/structured binding; деструктуризация → std::tie/structured bindings.
  - Символы: решить представление (interned string/id), синтаксис литерала (например, :foo), операции сравнения/хэш; runtime интернирование; C++ представление (например, uint64_t id + table). Пока этого нет.

  Концептуальных препятствий с C++ нет: кортежи → std::tuple или структуры; деструктуризация → structured bindings; символы → interned ids. Но нужно дописать полноценный проход (parser→IR→typecheck→backend) и runtime поддержку для символов. Сейчас это отсутствует.


› предложи полную концепцию, используя лучшие практики


• Концепция поддержки кортежей и символов с опорой на проверенные подходы:

  Кортежи (first-class)

  - Синтаксис:
      - Литералы: (a, b, c); однозначное отличие от группировки — правило: (x,) это кортеж из одного элемента, (x) — группировка.
      - Деструктуризация: let (x, y) = point_tuple;, в паттернах match: match t { (a, b) => ... }.
      - Spread/rest в паттернах (опционально позже): (head, *tail) или аналог.
  - Типы:
      - Tuple<T1, T2, ...> (фиксированной длины). В типах — атомарный конструктор, интернированный.
      - Инференс: (1, "hi") → Tuple<i32, str>.
  - Операции:
      - Доступ по позиции: t.0, t.1 (как в Rust), или get(t, 0).
      - Сравнение/хэш: лексикографическое/поэлементное (если все элементы сравнимы/хэшируемы).
  - IR/Backend:
      - SemanticIR: узел tuple literal, узел tuple access, паттерны кортежа.
      - C++: маппинг на std::tuple<...>; доступ — std::get<N>. Деструктуризация — structured bindings auto [x,y] = t; или std::tie.
  - Сопровождение:
      - Stdlib: функции fst/snd, map_tuple, zip/unzip, если нужно.
      - Проверка: в паттернах, при деструктуризации, число элементов должно совпадать.
  - Безопасность: tuple — значения без специфических правил владения (обычные value types); если элементы Shared/Weak, то несут свои правила.

  Символы (interned, first-class)

  - Синтаксис: литерал :foo (как в Ruby/Elixir), только идентификаторы, без пробелов. Интернированная строка.
  - Тип: Symbol — номинальный, сравнение/hashes O(1) по id.
  - Операции:
      - Сравнение == по id.
      - Хэш/Map/Set ключ: использовать id.
      - Преобразование в строку: symbol_to_string(:foo) -> "foo".
  - Runtime/Representation:
      - Intern таблица (hashmap) в runtime, символ хранит u64 id (или ptr на interned строку).
      - Погружение/вытаскивание строк: при парсинге интернируем, в runtime новые символы — через intern("...").
  - Интеграция с объектами/динамикой:
      - Открытые записи/Map могут использовать Symbol как ключ (ускорение доступа), но по умолчанию ключи — строки; допускаем оба.
      - Pattern matching: match sym { :ok => ... | :err => ... }.
  - Backend:
      - Тип Symbol → mlc::Symbol (runtime), хранящий id; interning таблица в runtime.

  Согласование с существующей моделью

  - Парсер: добавить tuple literal и символы; отличать (x,) от (x).
  - Semantic/type: добавить tuple nodes и Symbol type; инференс для tuple literals; паттерны tuple/symbol.
  - Backend: C++ маппинг tuple → std::tuple, symbol → runtime struct (uint64_t + table).
  - Diagnostics: ошибки несоответствия арности в деструктуризации, неизвестные символы — нет (символы интернируются всегда).

  Практики:

  - Rust-подобный доступ t.0 для tuple; Python-подобное сравнение/хэш.
  - Symbol — как interned string (Ruby/Elixir), O(1) сравнение, удобен как ключ в словаре.

  Такой дизайн даёт first-class кортежи/символы, с ясным поведением в типах, IR и бэкенде, без конфликтов с владением/безопасностью.


› не будет ли у нас где-то противоречий по синтаксису или архитектуре?


• На синтаксис/архитектуру это можно вписать без конфликтов, если явно зафиксировать пару правил:

  - Разводка скобок: (x,) — кортеж из одного элемента; (x) — группировка. Это снимает двусмысленность.
  - Доступ к кортежам: зарезервировать числовые “поля” вида .0, .1 только для tuple; не конфликтуют с record (record поля — идентификаторы).
  - Паттерны: деструктуризация кортежей в match/let — только по арности; spread/rest в паттерне пока не вводить, чтобы не пересечься с record/spread.
  - Символы: литерал :foo не конфликтует с текущим лексером (надо убедиться, что : не зарезервирован под другое); в парсере признавать :IDENT как SymbolLiteral.
  - Ключи в открытых формах/Map: по умолчанию строки; если ключ — Symbol, то маппинг к строке или отдельный кейс в runtime, но на синтаксис не влияет.
  - Backend: tuple → std::tuple, символ → interned id — не ломает C++ кодоген.

  Если эти правила положить в спецификацию лексера/парсера, противоречий не будет. Главное — не смешивать tuple literal с record (разные скобки) и не пересекать symbol literal с операторами. Остальное — вопрос реализации в IR/бэкенде.


› ключи в динамических record - это внутренний тип Key, к которому все другие типы естественным образом приводятся при обращении, а при колучении ключа поля как значения Key приводится автоматом к символу


• Можно так оформить:

  - Внутренний ключ: Key — интернированный тип (символ) для открытых записей/словарей. Хранится как Key (id), сравнение/хэш O(1).
  - Приведение при обращении: любой ключ (строка/символ/число) при обращении к полю в динамической записи автоматически приводится к Key. Для строк — интернирование, для символов — прямая передача id. Числа/прочее — через to_string→интернирование или явная ошибка, по договору.
  - Получение имени поля: при чтении ключа как значения — возвращается Key, который автоматически (бесшовно) приводится к Symbol/строке, если нужно (key -> Symbol, symbol_to_string(key)).
  - Это устраняет двоичную модель “строка vs символ” и даёт единый быстрый ключ для динамики; в статических записях имена полей остаются частью типа и не трогаются.

