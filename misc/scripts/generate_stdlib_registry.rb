#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate static stdlib registry from .mlc files

require 'json'

STDLIB_DIR = File.expand_path('../lib/mlc/common/stdlib', __dir__)
OUTPUT_FILE = File.expand_path('../lib/mlc/common/stdlib/registry.rb', __dir__)

# Parse metadata from .mlc file
def parse_metadata(file_path)
  content = File.read(file_path)
  metadata = {}

  content.scan(/^\/\/!\s*@(\w+)\s+(.+)$/) do |key, value|
    metadata[key.to_sym] = value.strip
  end

  metadata
end

# Scan all .mlc files recursively
def scan_stdlib_modules(base_dir)
  modules = []

  Dir.glob(File.join(base_dir, '**/*.mlc')).sort.each do |file_path|
    relative_path = file_path.sub(base_dir + '/', '')
    metadata = parse_metadata(file_path)

    next unless metadata[:module] # Skip files without @module metadata

    modules << {
      module: metadata[:module],
      category: metadata[:category],
      type: metadata[:type],
      namespace: metadata[:namespace],
      path: relative_path,
      full_path: file_path
    }
  end

  modules
end

puts "ðŸ” Scanning stdlib modules in #{STDLIB_DIR}..."
modules = scan_stdlib_modules(STDLIB_DIR)

puts "ðŸ“ Found #{modules.size} modules:"
modules.each do |mod|
  puts "  - #{mod[:module]} (#{mod[:type]}) â†’ #{mod[:path]}"
end

# Generate registry.rb
registry_content = <<~RUBY
  # frozen_string_literal: true
  # AUTO-GENERATED by scripts/generate_stdlib_registry.rb
  # DO NOT EDIT MANUALLY

  module MLC
    module Stdlib
      # Mapping of module names to module information
      REGISTRY = {
RUBY

modules.each do |mod|
  registry_content += <<~ENTRY
      "#{mod[:module]}" => {
        category: "#{mod[:category]}",
        type: :#{mod[:type]},
        #{"namespace: \"#{mod[:namespace]}\"," if mod[:namespace]}
        path: "#{mod[:path]}"
      },
  ENTRY
end

registry_content += <<~RUBY
    }.freeze

      # Legacy module name aliases for backward compatibility
      LEGACY_ALIASES = {
        "Option" => "std/core/option",
        "Result" => "std/core/result",
        "Array" => "std/collections/array",
        "String" => "std/text/string",
        "Conv" => "std/text/conv",
        "IO" => "std/io/io",
        "File" => "std/io/file",
        "Json" => "std/data/json",
        "Math" => "std/math/math",
        "Graphics" => "std/graphics/graphics"
      }.freeze

      def self.module_info(module_name)
        # Try direct lookup
        info = REGISTRY[module_name]
        return info if info

        # Try legacy alias
        canonical_name = LEGACY_ALIASES[module_name]
        REGISTRY[canonical_name] if canonical_name
      end

      def self.module_exists?(module_name)
        !module_info(module_name).nil?
      end

      def self.all_modules
        REGISTRY.keys
      end
    end
  end
RUBY

File.write(OUTPUT_FILE, registry_content)
puts "\nâœ¨ Registry generated: #{OUTPUT_FILE}"
puts "   #{modules.size} modules registered"
