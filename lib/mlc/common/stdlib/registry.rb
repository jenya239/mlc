# frozen_string_literal: true
# AUTO-GENERATED by scripts/generate_stdlib_registry.rb
# DO NOT EDIT MANUALLY

module MLC
  module Common
    module Stdlib
    # Mapping of module names to module information
    REGISTRY = {
"std/collections/array" => {
  category: "collections",
  type: :mixed,
  namespace: "mlc::collections",
  path: "collections/array.mlc"
},
"std/core/option" => {
  category: "core",
  type: :pure,
  
  path: "core/option.mlc"
},
"std/core/result" => {
  category: "core",
  type: :pure,
  
  path: "core/result.mlc"
},
"std/data/json" => {
  category: "data",
  type: :extern,
  namespace: "mlc::json",
  path: "data/json.mlc"
},
"std/graphics/graphics" => {
  category: "graphics",
  type: :extern,
  namespace: "mlc::graphics",
  path: "graphics/graphics.mlc"
},
"std/io/file" => {
  category: "io",
  type: :extern,
  namespace: "mlc::io",
  path: "io/file.mlc"
},
"std/io/io" => {
  category: "io",
  type: :extern,
  namespace: "mlc::io",
  path: "io/io.mlc"
},
"std/math/math" => {
  category: "math",
  type: :extern,
  namespace: "mlc::math",
  path: "math/math.mlc"
},
"std/text/conv" => {
  category: "text",
  type: :extern,
  namespace: "mlc",
  path: "text/conv.mlc"
},
"std/text/string" => {
  category: "text",
  type: :extern,
  namespace: "mlc",
  path: "text/string.mlc"
},
  }.freeze

    # Legacy module name aliases for backward compatibility
    LEGACY_ALIASES = {
      "Option" => "std/core/option",
      "Result" => "std/core/result",
      "Array" => "std/collections/array",
      "String" => "std/text/string",
      "Conv" => "std/text/conv",
      "IO" => "std/io/io",
      "File" => "std/io/file",
      "Json" => "std/data/json",
      "Math" => "std/math/math",
      "Graphics" => "std/graphics/graphics"
    }.freeze

    def self.module_info(module_name)
      # Try direct lookup
      info = REGISTRY[module_name]
      return info if info

      # Try legacy alias
      canonical_name = LEGACY_ALIASES[module_name]
      REGISTRY[canonical_name] if canonical_name
    end

    def self.module_exists?(module_name)
      !module_info(module_name).nil?
    end

    def self.all_modules
      REGISTRY.keys
    end
    end
  end
end
