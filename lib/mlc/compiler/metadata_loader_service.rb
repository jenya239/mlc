# frozen_string_literal: true

require 'json'

module MLC
  module Compiler
    # MetadataLoaderService
    # Phase 24-B: Load .mlcmeta files and register exported symbols
    #
    # Responsibilities:
    # - Read and parse .mlcmeta JSON files generated by MetadataGenerator
    # - Reconstruct FunctionSignature objects from metadata
    # - Register functions, types, and sum types in appropriate registries
    # - Enable cross-module compilation without re-parsing source files
    #
    # Usage:
    #   loader = MetadataLoaderService.new(
    #     function_registry: function_registry,
    #     type_registry: type_registry
    #   )
    #   loader.load("/path/to/module.mlcmeta")
    class MetadataLoaderService
      def initialize(function_registry:, type_registry:)
        @function_registry = function_registry
        @type_registry = type_registry
      end

      # Load metadata from .mlcmeta file and register symbols
      # @param metadata_path [String] Path to .mlcmeta file
      # @return [Boolean] true if loaded successfully, false if file doesn't exist
      def load(metadata_path)
        return false unless File.exist?(metadata_path)

        metadata = JSON.parse(File.read(metadata_path))
        module_name = metadata["module_name"]

        # Fallback: Use filename as module name if metadata contains default "main"
        # This allows modules without explicit module declarations to be imported by filename
        # Example: math.mlcmeta with module_name="main" -> module_name="math"
        if module_name == "main"
          module_name = File.basename(metadata_path, ".mlcmeta")
        end

        # Register exported functions
        metadata.dig("exports", "functions")&.each do |func_meta|
          register_function_from_metadata(func_meta, module_name)
        end

        # Register exported types
        metadata.dig("exports", "types")&.each do |type_meta|
          register_type_from_metadata(type_meta, module_name)
        end

        # Register sum types
        metadata.dig("exports", "sum_types")&.each do |sum_type_meta|
          register_sum_type_from_metadata(sum_type_meta, module_name)
        end

        true
      end

      private

      # Register function from metadata hash
      # @param func_meta [Hash] Function metadata from JSON
      # @param module_name [String] Name of the module (e.g., "Math", "Geometry")
      def register_function_from_metadata(func_meta, module_name)
        # Parse parameter types
        param_types = func_meta["params"].map do |param|
          parse_type(param["type"])
        end

        # Parse return type
        return_type = parse_type(func_meta["return_type"])

        # Create FunctionSignature
        signature = Core::FunctionSignature.new(
          func_meta["name"],
          param_types,
          return_type,
          [] # type_params - not yet in metadata
        )

        # Compute namespace from module name (e.g., "Math::Vector" -> "math::vector")
        namespace = module_name_to_namespace(module_name)

        # Register in FunctionRegistry
        @function_registry.register(
          func_meta["name"],
          signature,
          {
            namespace: namespace,
            module_name: module_name,
            exported: func_meta["is_exported"],
            external: false # Metadata only includes user-defined functions
          }
        )
      end

      # Register type from metadata hash
      # @param type_meta [Hash] Type metadata from JSON
      # @param module_name [String] Name of the module
      def register_type_from_metadata(type_meta, module_name)
        name = type_meta["name"]
        fields = type_meta["fields"].map do |field|
          {
            name: field["name"],
            type: parse_type(field["type"])
          }
        end

        # Create RecordType
        record_type = SemanticIR::RecordType.new(name: name, fields: fields)

        # Compute namespace
        namespace = module_name_to_namespace(module_name)

        # Register in TypeRegistry
        @type_registry.register(
          name,
          core_ir_type: record_type,
          kind: :record,
          namespace: namespace,
          module_name: module_name,
          exported: type_meta["is_exported"]
        )
      end

      # Register sum type from metadata hash
      # @param sum_type_meta [Hash] Sum type metadata from JSON
      # @param module_name [String] Name of the module
      def register_sum_type_from_metadata(sum_type_meta, module_name)
        name = sum_type_meta["name"]
        variants = sum_type_meta["variants"].map do |variant_name|
          { name: variant_name }
        end

        # Create SumType
        sum_type = SemanticIR::SumType.new(name: name, variants: variants)

        # Compute namespace
        namespace = module_name_to_namespace(module_name)

        # Register in TypeRegistry
        @type_registry.register(
          name,
          core_ir_type: sum_type,
          kind: :sum,
          namespace: namespace,
          module_name: module_name,
          exported: sum_type_meta["is_exported"]
        )
      end

      # Parse type string back to SemanticIR::Type
      # Handles primitives, generics, functions, etc.
      #
      # @param type_string [String] Type representation (e.g., "i32", "List<i32>", "(i32, i32) -> i32")
      # @return [SemanticIR::Type]
      def parse_type(type_string)
        # Handle function types: "(i32, i32) -> i32"
        if type_string =~ /\((.+)\)\s*->\s*(.+)/
          param_str = $1
          return_str = $2
          param_types = param_str.split(',').map { |p| parse_type(p.strip) }
          return_type = parse_type(return_str.strip)
          # FunctionType constructor: params: (array of {name:, type:}), ret_type:
          # For metadata, we don't have param names, so use p0, p1, etc.
          params = param_types.each_with_index.map do |type, idx|
            { name: "p#{idx}", type: type }
          end
          return SemanticIR::FunctionType.new(params: params, ret_type: return_type)
        end

        # Handle generic types: "Result<T, E>" or "List<i32>"
        if type_string =~ /^(\w+)<(.+)>$/
          base_name = $1
          type_args_str = $2
          type_args = parse_type_args(type_args_str)

          base_type = SemanticIR::Type.new(kind: :generic, name: base_name)
          return SemanticIR::GenericType.new(base_type: base_type, type_args: type_args)
        end

        # Handle array types: "i32[]"
        if type_string.end_with?("[]")
          element_type_name = type_string[0..-3]
          element_type = parse_type(element_type_name)
          return SemanticIR::ArrayType.new(element_type: element_type)
        end

        # Handle primitive and named types
        SemanticIR::Type.new(kind: primitive_kind(type_string), name: type_string)
      end

      # Parse comma-separated type arguments
      # @param args_str [String] "T, E" or "i32" or "i32, f32"
      # @return [Array<SemanticIR::Type>]
      def parse_type_args(args_str)
        # Simple split - doesn't handle nested generics yet
        # TODO: Proper parser for "List<Result<T, E>>" style nesting
        args_str.split(',').map { |arg| parse_type(arg.strip) }
      end

      # Determine if a type name is primitive
      # @param type_name [String]
      # @return [Symbol] :prim or :named
      def primitive_kind(type_name)
        case type_name
        when "i32", "i64", "f32", "f64", "bool", "str", "string", "void"
          :prim
        else
          :named
        end
      end

      # Convert module name to C++ namespace
      # "Math::Vector" -> "math::vector"
      # "Geometry" -> "geometry"
      # @param module_name [String]
      # @return [String]
      def module_name_to_namespace(module_name)
        module_name.downcase.gsub("::", "::")
      end
    end
  end
end
