#!/usr/bin/env ruby
# frozen_string_literal: true

require "optparse"
require "tmpdir"
require "open3"
require "fileutils"

ROOT_DIR = File.expand_path("..", __dir__)
RUNTIME_DIR = File.join(ROOT_DIR, "runtime")
DEFAULT_COMPILER = ENV.fetch("CXX", "g++")

$LOAD_PATH.unshift(File.join(ROOT_DIR, "lib"))
require "mlc/common/index"

def wrap_cpp(body)
  <<~CPP
    #include "mlc.hpp"

    #define main mlc_user_main
    #{body}
    #undef main

    static void mlc_cli_set_args(int argc, char** argv) {
      std::vector<mlc::String> arguments;
      arguments.reserve(argc > 0 ? argc - 1 : 0);
      for (int i = 1; i < argc; ++i) {
        arguments.emplace_back(argv[i]);
      }
      mlc::io::set_args(std::move(arguments));
    }

    int main(int argc, char** argv) {
      mlc_cli_set_args(argc, argv);
      return mlc_user_main();
    }
  CPP
end

def parse_arguments(argv)
  options = {
    compiler: DEFAULT_COMPILER,
    keep_tmp: false,
    emit_cpp: false,
    emit_cpp_output: nil,
    verbose: false
  }

  raw_args = []

  parser = OptionParser.new do |opts|
    opts.banner = "Usage: mlc [options] [file] [-- program-args]"

    opts.on("--emit-cpp", "Emit generated C++ to STDOUT") do
      options[:emit_cpp] = true
    end

    opts.on("-oFILE", "--output=FILE", "Write generated C++ to FILE (implies --emit-cpp)") do |file|
      options[:emit_cpp] = true
      options[:emit_cpp_output] = file
    end

    opts.on("--compiler=CMD", "C++ compiler command (default: #{DEFAULT_COMPILER})") do |cmd|
      options[:compiler] = cmd
    end

    opts.on("--keep-tmp", "Keep temporary build directory for inspection") do
      options[:keep_tmp] = true
    end

    opts.on("--verbose", "Print commands executed by the CLI") do
      options[:verbose] = true
    end

    opts.on("--version", "Show CLI version information") do
      puts "MLC CLI (experimental)"
      exit
    end

    opts.on("-h", "--help", "Show this help message") do
      puts opts
      exit
    end
  end

  argv_for_options = argv.dup
  separator_index = argv_for_options.index("--")
  program_args = separator_index ? argv_for_options[(separator_index + 1)..] : []
  program_args ||= []
  option_args = separator_index ? argv_for_options[0...separator_index] : argv_for_options

  begin
    parser.order!(option_args) { |nonopt| raw_args << nonopt }
  rescue OptionParser::ParseError => e
    warn e.message
    warn parser
    exit 1
  end

  input_args = raw_args

  if input_args.size > 1
    warn "Multiple input files provided: #{input_args.join(', ')}"
    warn parser
    exit 1
  end

  input_path = input_args.first
  { options: options, input_path: input_path, program_args: program_args }
end

def read_source(input_path)
  if input_path.nil?
    if STDIN.tty?
      warn "No input file provided. Pass a file path or pipe source code via STDIN."
      exit 1
    end
    [STDIN.read, "<stdin>"]
  elsif input_path == "-"
    [STDIN.read, "<stdin>"]
  else
    [File.read(input_path), input_path]
  end
rescue Errno::ENOENT
  warn "Input file not found: #{input_path}"
  exit 1
rescue Errno::EACCES
  warn "Cannot read input file: #{input_path}"
  exit 1
end

def emit_cpp(options, cpp_source)
  if (output = options[:emit_cpp_output])
    FileUtils.mkdir_p(File.dirname(output))
    File.write(output, cpp_source)
  else
    puts cpp_source
  end
end

def compile_cpp(options, cpp_source)
  dir = Dir.mktmpdir("mlc-cli")
  source_path = File.join(dir, "mlc_main.cpp")
  binary_path = File.join(dir, "mlc_program")

  File.write(source_path, cpp_source)

  runtime_cpp = File.join(RUNTIME_DIR, "src/core/string.cpp")
  runtime_io_cpp = File.join(RUNTIME_DIR, "src/io/io.cpp")

  # Get XCB and Cairo flags via pkg-config
  xcb_flags = `pkg-config --cflags --libs xcb cairo cairo-xcb 2>/dev/null`.strip.split
  xcb_flags = [] if $?.exitstatus != 0  # If pkg-config fails, continue without graphics

  compile_cmd = [
    options[:compiler],
    "-std=c++20",
    "-O2",
    "-I", File.join(RUNTIME_DIR, "include"),
    source_path,
    runtime_cpp,
    runtime_io_cpp,
    *xcb_flags,
    "-o", binary_path
  ]

  if options[:verbose]
    warn "Compiling: #{compile_cmd.join(' ')}"
  end

  stdout, stderr, status = Open3.capture3(*compile_cmd)

  unless status.success?
    warn stdout unless stdout.empty?
    warn stderr unless stderr.empty?
    warn "Compilation failed (status #{status.exitstatus})"
    warn "Command: #{compile_cmd.join(' ')}" if options[:verbose]
    exit status.exitstatus || 1
  end

  yield(binary_path, dir)
ensure
  if options[:keep_tmp]
    warn "Temporary build directory retained: #{dir}" if dir && options[:verbose]
  elsif dir && Dir.exist?(dir)
    FileUtils.remove_entry(dir)
  end
end

def run_program(binary_path, program_args, verbose:)
  if verbose
    warn "Running: #{([binary_path] + program_args).join(' ')}"
  end

  system(binary_path, *program_args)
  status = $?
  exit(status ? status.exitstatus : 1)
end

def main
  parsed = parse_arguments(ARGV.dup)
  options = parsed[:options]
  program_args = parsed[:program_args]
  input_path = parsed[:input_path]

  source_code, source_name = read_source(input_path)

  begin
    generated_cpp = MLC.to_cpp(source_code, filename: source_name)
  rescue MLC::ParseError, MLC::CompileError => e
    warn e.message
    exit 1
  end

  wrapped_cpp = wrap_cpp(generated_cpp)

  if options[:emit_cpp]
    emit_cpp(options, wrapped_cpp)
    return
  end

  compile_cpp(options, wrapped_cpp) do |binary_path, _temp_dir|
    run_program(binary_path, program_args, verbose: options[:verbose])
  end
end

main
