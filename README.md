# MLC - экспериментальный компилятор статически-типизированного языка в C++20

## Предупреждение об экспериментальном статусе

Данный проект представляет собой исследование возможностей генерации компилятора с использованием инструментов на основе больших языковых моделей. Проект не предназначен для промышленного использования.

**Код содержит:**
- Экспериментальные решения и архитектурные упрощения
- Отсутствие аудита безопасности
- Возможные ошибки и недоработанные функции

**Проект применим для:**
- Исследовательских целей в области AI-assisted разработки
- Образовательных задач по изучению архитектуры компиляторов
- Экспериментов с дизайном языков программирования

## Назначение проекта

MLC представляет собой экспериментальный компилятор, преобразующий исходный код на статически-типизированном языке высокого уровня в исходный код на C++20. Проект состоит из двух основных компонентов:

1. **Компилятор языка MLC** - полнофункциональный транслятор с многоуровневым промежуточным представлением
2. **C++ AST DSL** - Ruby DSL для программной генерации и манипуляции синтаксическими деревьями C++

Основной целью проекта является изучение практических возможностей современных AI-систем при разработке сложных систем обработки языков программирования.

## Архитектура компилятора

Компилятор реализован по классической многопроходной схеме с промежуточным представлением.

### Входные данные

Исходный код на языке MLC.

### Этап 1 - Лексический анализ

**Модуль:** `lib/mlc/source/lexer`

**Функция:** Преобразование текста в последовательность токенов

**Реализация:** Ручной лексер на Ruby с поддержкой всех синтаксических конструкций языка. Лексер распознает ключевые слова, идентификаторы, литералы, операторы и знаки пунктуации.

### Этап 2 - Синтаксический анализ

**Модуль:** `lib/mlc/source/parser`

**Функция:** Построение абстрактного синтаксического дерева (AST)

**Структура:** AST представлен классом `MLC::AST::Program`, содержащим декларации функций, типов и модулей. Парсер реализует рекурсивный спуск с обработкой приоритетов операторов.

### Этап 3 - Семантический анализ и трансформация

**Модуль:** `lib/mlc/representations/semantic_ir`

**Функция:** Проверка типов, разрешение имен, построение SemanticIR

**Промежуточное представление:** Типизированное дерево с явными типами всех выражений. SemanticIR включает информацию о типах, разрешенных именах и проверенных конструкциях.

### Этап 4 - Генерация кода

**Модуль:** `lib/mlc/backends/cpp`

**Функция:** Преобразование SemanticIR в C++ AST, затем в исходный код C++

**Стратегия:** Применяется Strangler Fig Pattern - постепенная миграция на новую архитектуру бэкенда. Существует два бэкенда:
- Legacy backend - оригинальная реализация
- Backends::Cpp v2 - новая модульная архитектура с улучшенной генерацией кода

### Выходные данные

Исходный код на C++20, готовый к компиляции системным компилятором.

## Язык MLC

Язык MLC представляет собой статически-типизированный функциональный язык с императивными элементами.

### Система типов

**Примитивные типы:**
- Целочисленные: `i32`, `i64`
- Числа с плавающей точкой: `f32`, `f64`
- Логический тип: `bool`
- Строковый тип: `str`
- Тип без значения: `void`

**Алгебраические типы данных:**

Sum types (размеченные объединения) позволяют определять типы, которые могут принимать одно из нескольких заданных значений:

```mlc
type Result<T, E> = Ok(T) | Err(E)
type Option<T> = Some(T) | None
```

**Произведения типов:**

Record types представляют структуры с именованными полями:

```mlc
type Point = { x: f32, y: f32 }
type Person = { name: str, age: i32 }
```

**Параметрический полиморфизм:**

Обобщенные типы с параметрами типов:

```mlc
type List<T> = Cons(T, List<T>) | Nil
type Pair<A, B> = { first: A, second: B }
```

### Основные конструкции

**Определение функции:**

```mlc
fn divide(a: i32, b: i32) -> Result<i32, str> =
  if b == 0 then
    Err("division by zero")
  else
    Ok(a / b)
```

**Сопоставление с образцом:**

```mlc
fn process_result(result: Result<i32, str>) -> i32 =
  match result
    | Ok(value) => value * 2
    | Err(error) => 0
```

**Определение типа:**

```mlc
type Shape =
  | Circle(f32)
  | Rectangle(f32, f32)
  | Point
```

**Блоки с let-биндингами:**

```mlc
fn compute() -> i32 =
  let x = 10;
  let y = 20;
  x + y
```

### Реализация pattern matching

**Компиляция в C++:**
- Sum types транслируются в `std::variant<...>`
- Pattern matching реализуется через `std::visit` с lambda-overloads
- Компилятор генерирует структуры для каждого варианта типа
- Гарантируется полнота проверки всех вариантов на этапе компиляции

**Пример генерации:**

MLC код:
```mlc
type Result = Ok(i32) | Err

fn unwrap(res: Result) -> i32 =
  match res
    | Ok(value) => value
    | Err => 0
```

Генерируется в C++:
```cpp
#include "mlc/core/match.hpp"

struct Ok { int field0; };
struct Err {};
using Result = std::variant<Ok, Err>;

int unwrap(Result res) noexcept {
  return std::visit(overloaded{
    [](const Ok& ok) { return ok.field0; },
    [](const Err& err) { return 0; }
  }, res);
}
```

## Компилятор и инструментарий

### Исполняемый файл

**Расположение:** `bin/mlc`

### Последовательность операций

1. Чтение исходного кода из файла или stdin
2. Лексический анализ - токенизация исходного текста
3. Синтаксический анализ - построение AST
4. Семантический анализ - проверка типов, построение SemanticIR
5. Генерация C++ кода из SemanticIR
6. Вызов системного компилятора C++ (g++ или clang++)
7. Опционально - запуск скомпилированного бинарного файла

### Режимы работы

**Компиляция и запуск:**
```bash
bin/mlc examples/hello.mlc
```

**Вывод сгенерированного C++:**
```bash
bin/mlc --emit-cpp program.mlc
```

**Сохранение временных файлов:**
```bash
bin/mlc --keep-tmp program.mlc
```

**Чтение из stdin:**
```bash
echo 'fn main() -> i32 = 42' | bin/mlc -
```

**Передача аргументов программе:**
```bash
bin/mlc program.mlc -- arg1 arg2 arg3
```

### Опции компилятора

- `--emit-cpp` - вывести сгенерированный C++ код вместо компиляции
- `--keep-tmp` - сохранить временную директорию с промежуточными файлами
- `-` - читать исходный код из stdin

## Runtime библиотека

**Расположение:** `runtime/include/mlc/`

Runtime библиотека предоставляет набор модулей для работы с различными типами данных и операциями.

### Модульная структура

**core/** - Базовые типы и утилиты
- `match.hpp` - Определение структуры `overloaded` для pattern matching через `std::visit`
- `types.hpp` - Общие определения типов

**text/** - Работа с текстом
- `string.hpp` - Строковый тип с поддержкой UTF-8
- `regex.hpp` - Регулярные выражения на основе std::regex

**io/** - Ввод-вывод
- `file.hpp` - Операции с файлами
- `buffer.hpp` - Буферизованный ввод-вывод

**math/** - Математические операции
- `vector.hpp` - Векторная математика
- `functions.hpp` - Математические функции

**json/** - Работа с JSON
- `parser.hpp` - Парсинг JSON
- `serializer.hpp` - Сериализация в JSON

**graphics/** - Графические примитивы
- `color.hpp` - Представление цвета (RGBA)
- `rect.hpp` - Прямоугольники и геометрические примитивы

### Особенности реализации

Все компоненты runtime написаны на современном C++20 с использованием:
- Концептов для ограничения типов
- Ranges для обработки последовательностей
- constexpr функций для вычислений на этапе компиляции
- noexcept спецификаций для оптимизации

## C++ AST DSL

Ruby DSL для программной генерации синтаксических деревьев C++.

### Архитектура

**Модуль:** `lib/cpp_ast`

**Компоненты:**
- **Узлы AST:** `lib/cpp_ast/nodes/` - Классы, представляющие элементы синтаксического дерева C++
- **Builder API:** `lib/cpp_ast/builder/dsl.rb` - DSL функции для построения AST
- **Генератор:** `lib/cpp_ast/builder/dsl_generator.rb` - Преобразование AST в исходный код C++
- **Лексер:** `lib/cpp_ast/lexer/` - Токенизация C++ кода
- **Парсеры:** `lib/cpp_ast/parsers/` - Парсинг C++ в AST

### Поддерживаемые конструкции C++

**Объектно-ориентированное программирование:**
- Классы и структуры
- Одиночное наследование
- Множественное наследование
- Виртуальное наследование
- Виртуальные методы
- Спецификаторы: `virtual`, `override`, `final`, `pure virtual`
- Секции доступа: `public`, `protected`, `private`
- Friend-декларации

**Шаблоны:**
- Обычные шаблоны функций и классов
- Вариадные шаблоны
- Template template параметры
- Специализации шаблонов

**C++20 возможности:**
- Концепты (concepts) с требованиями
- Модули (modules) с import/export
- Корутины (coroutines) с co_await, co_yield, co_return

**Прочее:**
- Пространства имен
- Статические члены
- constexpr функции и переменные
- Атрибуты: `[[nodiscard]]`, `[[maybe_unused]]`, `[[deprecated]]`
- Комментарии: inline `//`, block `/* */`, doxygen `///`
- Препроцессор: `#define`, `#ifdef`, `#ifndef`, `#include`

### Пример использования DSL

```ruby
require 'cpp_ast'
include CppAst::Builder::DSL

# Создание класса с виртуальными методами
my_class = class_with_inheritance("Shape", ["public Drawable"]).tap do |klass|
  klass.members = [
    public_section(
      function_decl("void", "draw", []).virtual().pure_virtual(),
      function_decl("double", "area", []).const().virtual()
    ),
    protected_section(
      var_decl("int", "id")
    )
  ]
end

puts my_class.to_source
```

### Roundtrip capability

DSL поддерживает двунаправленное преобразование:
- **Ruby DSL → C++ код:** Генерация исходного кода из DSL структур
- **C++ код → Ruby DSL:** Парсинг C++ кода обратно в DSL структуры

Это позволяет:
- Программно модифицировать существующий C++ код
- Анализировать структуру C++ программ
- Генерировать код по шаблонам

## Процесс генерации кодовой базы с использованием AI

Кодовая база проекта была сгенерирована с использованием следующих инструментов на основе больших языковых моделей.

### Использованные инструменты

**Claude (Anthropic):**
- Разработка архитектурных решений компилятора
- Реализация ключевых алгоритмов лексического и синтаксического анализа
- Разработка системы типов и семантического анализа
- Реализация генератора кода для C++
- Рефакторинг кодовой базы
- Написание технической документации
- Диагностика и исправление ошибок
- Оптимизация производительности

**GitHub Copilot:**
- Автодополнение реализаций функций
- Генерация модульных тестов
- Написание вспомогательных методов и утилит
- Создание примеров использования

**Cursor:**
- Интерактивная разработка новых функций
- Отладка проблем в коде
- Рефакторинг существующих модулей
- Интеграция компонентов

### Процентное соотношение

Более 85% кодовой базы было создано с использованием AI-инструментов.

**Ручное вмешательство потребовалось для:**
- Определения высокоуровневой архитектуры компилятора
- Написания спецификаций языка MLC
- Формулирования требований к компонентам
- Проверки корректности сгенерированного кода
- Интеграции разрозненных компонентов
- Принятия архитектурных решений

### Методология разработки

Разработка велась итеративно:
1. Формулирование требований к компоненту
2. Генерация кода с использованием AI
3. Проверка корректности через тесты
4. Рефакторинг и оптимизация
5. Интеграция с остальной системой

Такой подход позволил создать работающий компилятор за существенно меньшее время по сравнению с традиционной разработкой.

## Технические детали реализации

### Используемые технологии

**Язык реализации компилятора:** Ruby 3.x

**Целевой язык:** C++20

**Система сборки:** Rakefile

**Тестовый фреймворк:** Minitest

**Требования к системному компилятору:**
- g++ >= 10.0 с поддержкой C++20
- clang++ >= 11.0 с поддержкой C++20

### Архитектурные паттерны

**Visitor pattern:**
Используется для обхода AST и SemanticIR. Каждый узел дерева принимает visitor, который выполняет специфичную для типа узла обработку.

**Strategy pattern:**
Применяется для выбора стратегии генерации кода в зависимости от типа конструкции и целевой платформы.

**Strangler Fig pattern:**
Используется для постепенной миграции с legacy бэкенда на новую архитектуру Backends::Cpp v2 без остановки разработки.

**Builder pattern:**
Применяется для построения сложных C++ AST структур через fluent API.

### Структура каталогов

```
lib/
├── cpp_ast/              # C++ AST DSL
│   ├── builder/          # API для построения AST
│   │   ├── dsl.rb        # Основной DSL
│   │   ├── fluent.rb     # Fluent API extensions
│   │   └── dsl_generator.rb  # Генератор C++ кода
│   ├── nodes/            # Классы узлов AST
│   │   ├── declarations.rb
│   │   ├── statements.rb
│   │   ├── expressions.rb
│   │   └── types.rb
│   ├── lexer/            # Лексер для C++
│   │   └── lexer.rb
│   └── parsers/          # Парсеры для C++
│       ├── expression_parser.rb
│       ├── statement_parser.rb
│       └── declaration_parser.rb
└── mlc/                  # Компилятор MLC
    ├── source/           # Frontend
    │   ├── lexer/        # Лексический анализ
    │   └── parser/       # Синтаксический анализ
    ├── representations/  # Промежуточные представления
    │   └── semantic_ir/  # Семантическое IR
    ├── backends/         # Code generation
    │   └── cpp/          # C++ backend
    └── common/           # Общие утилиты
        ├── ast/          # Определения AST узлов
        └── stdlib/       # Стандартная библиотека MLC

runtime/
└── include/mlc/          # Runtime библиотека C++
    ├── core/             # Базовые компоненты
    ├── text/             # Строки и регулярные выражения
    ├── io/               # Ввод-вывод
    ├── math/             # Математика
    ├── json/             # JSON
    └── graphics/         # Графика

test/                     # Тесты
├── cpp_ast/              # Тесты C++ AST DSL
├── mlc/                  # Тесты компилятора MLC
└── integration/          # Интеграционные тесты
```

### Ключевые модули

**Лексер MLC:** `lib/mlc/source/lexer/lexer.rb`
Преобразует исходный текст в поток токенов. Поддерживает все конструкции языка MLC.

**Парсер MLC:** `lib/mlc/source/parser/parser.rb`
Строит AST из потока токенов. Реализован методом рекурсивного спуска.

**Семантический анализ:** `lib/mlc/representations/semantic_ir/`
Проверяет типы, разрешает имена, строит типизированное IR.

**Генератор C++:** `lib/mlc/backends/cpp/`
Преобразует SemanticIR в C++ AST, затем генерирует исходный код.

## Установка и использование

### Системные требования

**Обязательные компоненты:**
- Ruby >= 3.0
- Компилятор C++20:
  - g++ >= 10.0 или
  - clang++ >= 11.0
- rake

**Опциональные компоненты:**
- git для клонирования репозитория

### Установка

```bash
git clone <repository-url>
cd mlc
```

### Запуск тестов

```bash
rake test
```

Все тесты должны пройти успешно.

### Компиляция программы MLC

**Простейшая программа:**

Создайте файл `hello.mlc`:
```mlc
fn main() -> i32 =
  42
```

Скомпилируйте и запустите:
```bash
bin/mlc hello.mlc
echo $?  # Выведет: 42
```

**Программа с pattern matching:**

Создайте файл `result.mlc`:
```mlc
type Result = Ok(i32) | Err

fn divide(a: i32, b: i32) -> Result =
  if b == 0 then Err else Ok(a / b)

fn main() -> i32 =
  match divide(10, 2)
    | Ok(value) => value
    | Err => 0
```

Скомпилируйте и запустите:
```bash
bin/mlc result.mlc
echo $?  # Выведет: 5
```

### Генерация C++ кода

```bash
bin/mlc --emit-cpp program.mlc > output.cpp
```

Сгенерированный файл `output.cpp` будет содержать код на C++20.

### Отладка

Для сохранения временных файлов используйте:
```bash
bin/mlc --keep-tmp program.mlc
```

Временная директория будет выведена в консоль и не будет удалена после компиляции.

## Результаты тестирования

### Текущее состояние

```
1528 runs, 4028 assertions, 0 failures, 0 errors, 0 skips
```

Все тесты проходят успешно.

### Покрытие компонентов

**Лексер и парсер:**
- Полное покрытие всех конструкций языка MLC
- Тесты на корректность распознавания токенов
- Тесты на построение корректного AST

**Семантический анализ:**
- Проверка корректности системы типов
- Тесты на разрешение имен
- Проверка обнаружения ошибок типизации

**Генерация кода:**
- Тесты на корректность сгенерированного C++
- Проверка компиляции сгенерированного кода
- Тесты на корректность исполнения

**C++ AST DSL:**
- Тесты на построение всех конструкций C++
- Проверка генерации корректного синтаксиса
- Roundtrip тесты (DSL → C++ → DSL)

**Интеграционные тесты:**
- Компиляция примеров программ
- Запуск и проверка результатов
- Тесты на корректность pattern matching
- Проверка работы с sum types

### Распределение тестов

- Модуль C++ AST DSL: ~1000 тестов
- Модуль компилятора MLC: ~400 тестов
- Интеграционные тесты: ~128 тестов

## Ограничения и область применения

### Проект не предназначен для

**Промышленное использование:**
Код не прошел аудита безопасности и не тестировался на production-нагрузках.

**Критичные по безопасности приложения:**
Компилятор может содержать уязвимости и не предоставляет гарантий безопасности.

**Высоконагруженные системы:**
Отсутствует оптимизация производительности сгенерированного кода.

### Проект предназначен для

**Исследования возможностей AI:**
Демонстрация применения AI-инструментов для создания компиляторов.

**Образовательные цели:**
Изучение архитектуры компиляторов, промежуточных представлений, генерации кода.

**Эксперименты с языками:**
Прототипирование идей дизайна языков программирования.

**Исследования по компиляторам:**
База для исследований в области трансляции и оптимизации кода.

### Известные ограничения

**Оптимизация:**
Отсутствует оптимизация сгенерированного кода. Генерируется прямолинейный код без оптимизаций.

**Сообщения об ошибках:**
Диагностика ошибок требует улучшения. Сообщения могут быть недостаточно информативными.

**Инкрементальная компиляция:**
Отсутствует поддержка инкрементальной компиляции. Каждый запуск компилирует всю программу заново.

**Система модулей:**
Система модулей реализована частично. Не все возможности модульной системы доступны.

**Стандартная библиотека:**
Стандартная библиотека содержит ограниченный набор функций. Многие утилиты требуют реализации.

### Перспективы развития

Проект может служить основой для дальнейших исследований в области:
- AI-assisted компиляторов
- Автоматической генерации оптимизаций
- Улучшения диагностики ошибок с помощью AI
- Разработки DSL для специфичных доменов
